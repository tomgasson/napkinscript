// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`apply.js 1`] = `
"console.log()
Js.log(\\"arg1\\", \\"arg2\\")
let rbt = make(~compare)
let rbt = make(~compare?)
let rbt = make(~compare=intCompare)
let rbt = make(~compare=?intCompare)
let rbt = make(~compare=?intCompare: (int, int) => int)

let () = applyFunctionToArguments(
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
)

let cmp = rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value)
let cmp = rbt.compare2(.
  Js.Array2.unsafe_get(old, oldIter.contents),
  longerNode.longValue,
)
let uncurriedUnit = apply(.)

let coordinate = make2dCoordinate({x: 1, y: 2})
let coordinate = make3dCoordinate({
  ...base,
  field1: thisIsAPrettyLongNameHere,
  field2: thisIsAPrettyLongNameHere,
  field3: thisIsAPrettyLongNameHere,
})

let coordinate = make2dCoordinateArray([x, y])
let coordinate = make3dCoordinateArray([
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
])

let coordinate = make2dCoordinateTuple((x, y))
let coordinate = make3dCoordinateTuple((
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
))

let coordinate = make2dCoordinateList(list[x, y])
let coordinate = make3dCoordinateList(list[
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  ...allCoords,
])

let coordinate = makeJsCoordinate({\\"x\\": 1, \\"y\\": 1})
let user = makeJsUser({
  \\"name\\": \\"steve\\",
  \\"age\\": 32,
})

let x = @attr callFunction()
let x =
  @attrWithLongName @attrWithLongName @attrWithLongName @attrWithLongName
  callFunction()

"
`;

exports[`array.js 1`] = `
"let x = []
let x = [a, b, c]
let x = [
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
]

let x = @attr [a, b, c]
let x = @attr [@attr a, @attr b, @attr c]

let x =
  @attr
  [
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  ]

let x = [biggerThanZero ? 1 : 0, biggerThanZero ? 1 : 0]

"
`;

exports[`arrayGet.js 1`] = `
"let street = streets[0]

let streetWithAVeryVeryVerrrrrrryVeeeeeeeeeryLongName =
  streetsAddressBookThisIsALongName[0]

let streetWithAVeryVeryVerrrrrrryVeeeeeeeeeryLongName =
  streetsAddressBookThisIsALongName[streets->Belt.Array.length - 1]

let streetWithAVeryVeryVerrrrrrryVeeeeeeeeeryLongName =
  streetsAddressBookThisIsALongName[
    streetsAddressBookThisIsALongName.streets->Belt.Array.length - 1
  ]

let street = @attr streets[0]

"
`;

exports[`assert.js 1`] = `
"assert false

assert truth

let x = assert true
let x = assert 12
let x = assert (12: int)
let x = assert 12
let x = assert list[1, 2, ...x]
let x = assert module(Foo: Bar)
let x = assert module(Foo)
let x = assert Rgb(1, 2, 3)
let x = assert [a, b, c]
let x = assert {x: 1, y: 3}
let x = assert (1, 2, 3)
let x = assert %extension
let x = assert user.name
let x = assert streets[0]
let x = assert apply(arg1, arg2)
let x = assert apply(. arg1, arg2)
let x = assert -1
let x = assert !true
let x = assert (x => print(x))
let x = assert (
  switch x {
  | Blue => ()
  | Yello => ()
  }
)

let x = assert (
  for i in 0 to 10 {
    print_int(i)
  }
)

let x = assert (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
)

let x = assert (
  while i < 10 {
    print_int(i)
  }
)

let x = assert (lazy false)
let x = assert (
  try sideEffect() catch {
  | Exit => ()
  }
)

let x = assert (@attr expr)

let x = assert (a + b)

let x = @attr assert false

assert invariant[\\"fatal\\"]
assert invariants[0]

assert address[\\"street\\"] = \\"Brusselsestraat\\"

assert (true ? 0 : 1)

"
`;

exports[`binary.js 1`] = `
"let x = a + b
let x = @attr (a + b)
let x = @attr (@attr a + @attr b)
let x = a && b + c
let x = (a && b) + c
let x = (a && b) || c

let x = (a && b) + (c && d)

while (
  continuePrefix.contents &&
  aPrefixLen.contents &&
  bPrefixLen.contents &&
  foobarLen.contents
) {
  ()
}

// uncurried attribute shouldn't result in parens
while (
  rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value) < 0
) {
  ()
}

// unary expr as child of binary expr doesn't need parens
let x =
  !filePath.includes(allMlSuffixesCategory) &&
  !filePath.endsWith(allScriptDirectoriesCategory)

let name = names[0] ++ names[1]
let name = user[\\"firstName\\"] ++ user[\\"lastName\\"]

let x = foo ++ bar
let x = foo != bar
let x = foo !== bar

let x = foo ++ bar
let x = 1 + 1
let x = (a => a + 1) + (b => b + 2)
let x = -1 + -1
let x =
  switch z {
  | Red => 1
  } |> switch y {
  | Blue => 2
  }
let x =
  try z catch {
  | Exit => 1
  } |> try y catch {
  | Blue => 2
  }
let x =
  if true {
    1
  } else {
    2
  } + if false {
    2
  } else {
    3
  }
let x =
  for i in 0 to 10 {
    ()
  } |> for i in 0 to 10 {
    ()
  }

let x = (a, b) + (b, c)
let x = Vec3(a, b, c) + Vec4(a, b, c, d)
let x = {x: 1, y: 2} + {x: 2, y: 3}
let x = user.firstName ++ user.lastName
let x = x.left = value |> x.right = value
let x = (x.left = value) |> x.right = value
let x = (x.left = value) |> x.right = value
let () = (x.left = value) |> logMutation
let () = x.left = value |> logMutation
let () = x.left = value |> process |> x.right = value |> process
let () = (x: int) |> (print_int: int => unit)

// math
x + y / z
x / y + z
(100 * x) / total
((2 / 3) * 10) / 2 + 2
let rotateX =
  ((range / rect.height) * refY - range / 2) * getXMultiplication(rect.width)
let rotateY =
  ((range / rect.width) * refX - range / 2) * getYMultiplication(rect.width)

let x = longIdentifier + longIdentifier + longIdentifier
let x =
  longIdentifier +
  longIdentifier +
  longIdentifier +
  longIdentifier -
  longIdentifier +
  longIdentifier
let x =
  longIdentifier +
  longIdentifier * longIdentifier +
  longIdentifier -
  longIdentifier +
  longIdentifier
let x =
  longIdentifier +
  (longIdentifier * longIdentifier * longIdentifier) / longIdentifier +
  longIdentifier

let x =
  longIdentifier &&
  longIdentifier &&
  longIdentifier &&
  longIdentifier &&
  longIdentifier &&
  longIdentifier
let x =
  (longIdentifier && longIdentifier) ||
  longIdentifier && longIdentifier ||
  (longIdentifier && longIdentifier)

if (
  successorParent.color === Black &&
    (sibling === None ||
      (siblingNN.color === Black && siblingNN.left === None) ||
      (siblingNN.left->castNotOption).color === Black &&
        (siblingNN.right === None ||
          (siblingNN.right->castNotOption).color === Black))
) {
  if sibling !== None {
    siblingNN.color = Red
  }
  successorRef.contents = successorParent
}

let truth =
  longEqualityExpression.someRecordField ==
    wowThisDoesHaveToBePrettyLong.someRecordField &&
    longEqualityExpression.someRecordField ==
      wowThisDoesHaveToBePrettyLong.someRecordField

while (
  continuePrefix.contents &&
  aPrefixLen.contents <= aLen &&
  bPrefixLen.contents <= bLen
) {
  let nextNonwhiteA = nextNonWhiteChar(aStr, 1, aPrefixLen.contents - 1)
  let nextNonwhiteB = nextNonWhiteChar(bStr, 1, bPrefixLen.contents - 1)
  ()
}
let () = {
  let () = sideEffect()
  if (
    (isLeft(successor) && sibling.right === None) ||
      ((sibling.right->castNotOption).color === Black &&
      sibling.left !== None &&
      (sibling.left->castNotOption).color === Red)
  ) {
    sibling.color = Red
    sibling.left->castNotOption.color = Black
    rotateRight(rbt, sibling)
  }
  if sibling !== None && (sibling->castNotOption).color === Black {
    let sibling = sibling->castNotOption
    if (
      (isLeft(successor) && sibling.right === None) ||
        ((sibling.right->castNotOption).color === Black &&
        sibling.left !== None &&
        (sibling.left->castNotOption).color === Red)
    ) {
      sibling.color = Red
      sibling.left->castNotOption.color = Black
      rotateRight(rbt, sibling)
    } else if (
      (!isLeft(successor) && sibling.left === None) ||
        ((sibling.left->castNotOption).color === Black &&
        sibling.right !== None &&
        (sibling.right->castNotOption).color === Red)
    ) {
      sibling.color = Red
      sibling.right->castNotOption.color = Black
      rotateLeft(rbt, sibling)
    }
    break.contents = true
  } else {
    let sibling = siblingOf(successor)
    let sibling = sibling->castNotOption
    sibling.color = successorParent.color
    if isLeft(successor) {
      sibling.right->castNotOption.color = Black
      rotateRight(rbt, successorParent)
    } else {
      sibling.left->castNotOption.color = Black
      rotateLeft(rbt, successorParent)
    }
  }
}

let x = a && (b || c)
let x = a && (b || c) && d
let x = a && b + c
let x = a && b + c && d

let x = a && @attr b && c
let x = @attr a && @attr b && @attr c
let x = a && @attr (b && c)
let x = a && @attr (b && c) && @attr (d && e)

let x = a && @attr (x |> f(g))
let x = a && @attr (x |> f(g)) && @attr (y |> f(h))

let x = a && a.b
let x = a && x.y && g.h
let x = a && true
let x = a && true && true
let x =
  a && {
    let a = true
    let b = true
    a || b
  }
let x =
  a &&
  {
    let a = true
    let b = true
    a || b
  } && {
    let a = true
    let b = true
    a || b
  }

let x = a && (x => x->Js.log)
let x = a && (x => x->Js.log) && (x => x->Js.log)

let x = a && !b
let x = a && !b && !c

let x = a && f(b)
let x = a && f(b) && f(c)

let x = a && f(. b)
let x = a && f(. b) && f(. c)

let x = a && x |> f(g)
let x = a && x |> f(g) && y |> f(h)

let x =
  a &&
  switch color {
  | Blue => \\"blue\\"
  | Red => \\"red\\"
  }
let x =
  a &&
  switch color {
  | Blue => \\"blue\\"
  | Red => \\"red\\"
  } &&
  switch color {
  | Blue => \\"blue\\"
  | Red => \\"red\\"
  }

let x =
  a && try unsafe() catch {
  | Error => ()
  }

let x =
  a &&
  try unsafe() catch {
  | Error => ()
  } && try unsafe() catch {
  | Error => ()
  }

let x = a && (a, b)
let x = a && (a, b) && (c, d)

let x = a && Foo(x, y)
let x = a && Foo(x, y) && Foo(x, y, z)

let x = a && {x: 1, y: 2}
let x = a && {x: 1, y: 2} && {x: 3, y: 3}

let x = a && b.c
let x = a && b.c && d.e

let x = a && row.id = 1
let x = a && (row.id = 1) && row2.id = 3

let x = a && [a, b]
let x = a && [a, b] && [c, d]

let x =
  a && if true {
    true
  } else {
    false
  }
let x =
  a &&
  if true {
    true
  } else {
    false
  } && if false {
    false
  } else {
    true
  }

let x =
  a && {
    sideEffect()
    do()
  }
let x =
  a &&
  {
    sideEffect()
    do()
  } && {
    sideEffect()
    do()
  }

let x =
  a && while true {
    do()
  }
let x =
  a &&
  while true {
    do()
  } && while true {
    do()
  }

let x =
  a && for i in 0 to 10 {
    true
  }
let x =
  a &&
  for i in 0 to 10 {
    true
  } && for i in 0 to 10 {
    false
  }

let x = a && (truth: bool)
let x = a && (truth: bool) && (otherTruth: bool)

let x =
  a && {
    module L = Log
    L.log()
  }
let x =
  a &&
  {
    module L = Log
    L.log()
  } && {
    module L = Log
    L.log()
  }

let x =
  a && {
    exception Exit
    raise(Exit)
  }
let x =
  a &&
  {
    exception Exit
    raise(Exit)
  } && {
    exception Exit
    raise(Exit)
  }

let x = a && assert false
let x = a && assert false && assert true

let x = a && lazy false
let x = a && lazy false && lazy true

let x =
  a && {
    open React
    killPerform()
  }
let x =
  a &&
  {
    open React
    killPerform()
  } && {
    open Dom
    regainPerform()
  }

let x = a && %bs.raw(\\"true\\")
let x = a && %bs.raw(\\"true\\") && %bs.raw(\\"false\\")

let x = a && module(Foo)
let x = a && module(Foo) && module(Bar)

let x = a && module(Foo: Bool)
let x = a && module(Foo: Bool) && module(Bar: Bool)

let x = a && truths[0]
let x = a && truths[0] && truths[1]

let () = node.left := value |> process |> node.right = value |> process
let () = (node.left := value |> process) |> node.right = value |> process

let x = (true ? 0 : 1) + (false ? 1 : 0)
let x = (true ? 0 : 1) + (false ? 1 : 0) + (false ? 1 : 0)

while (
  oldIter.contents < oldLen &&
    rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value)
) {
  disappear(. Js.Array2.unsafe_get(old, oldIter.contents))
  oldIter.contents = oldIter.contents + 1
}

while (
  oldIter.contents < oldLen &&
    rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value) < 0
) {
  disappear(. Js.Array2.unsafe_get(old, oldIter.contents))
  oldIter.contents = oldIter.contents + 1
}

let x =
  oldIter.contents < oldLen &&
    rbt.compare(Js.Array2.unsafe_get(old, oldIter.contents), node.value) <
    veryLongIdentifier

// should be formatted on one line, i.e. NOT break
let fullCircle = 2. *. pi

"
`;

exports[`block.js 1`] = `
"let x = {
  module Foo = Bar
  exception Exit
  open Belt
  let a = 1
  let b = 2
  sideEffect()
  sideEffect2()
  ()
}

"
`;

exports[`bsObj.js 1`] = `
"let user = {
  \\"name\\": \\"Steve\\",
  \\"age\\": 30,
}

let coord = {\\"x\\": 1, \\"y\\": 2}

let person = {
  \\"name\\": {
    \\"first\\": \\"Bob\\",
    \\"last\\": \\"Zhmith\\",
  },
  \\"age\\": 32,
}

"
`;

exports[`callback.js 1`] = `
"array->Js.Array2.forEach(((value, height)) => add(rbt, value, ~height)->ignore)
someArray->Js.Array2.forEach(((value, height)) =>
  add(rbt, value, ~height)->ignore
)
someArraaaaaaayWithAVeryLooooooooooooooooooooooooooooooooooooooongName->Js.Array2.forEach(
  ((value, height)) => add(rbt, value, ~height)->ignore,
)

let make = (arr, ~compare) => {
  let rbt = make(~compare)
  array->Js.Array2.forEach(((value, height)) =>
    add(rbt, value, ~height)->ignore
  )
  rbt
}

Thing.map(foo, (arg1, arg2) => MyModuleBlah.toList(argument))
Thing.map(foo, bar, baz, (aaaaaaaaaaarg1, aaaaarg2) =>
  MyModuleBlah.toList(argument)
)
Thing.map(fooooooooooooooooooo, bar, baz, (abc, z) =>
  MyModuleBlah.toList(argument)
)
Thing.map(
  fooooooooooooooooooo,
  baaaaaaaaaaaaaaaaaar,
  baaaaaaaaaaaaaaaaaaaaaaaaaz,
  (abc, z) => MyModuleBlah.toList(argument),
)
Fooooooooooooooooooo.baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
  baaaz,
  quuuuux => something(here),
)

Fooooooooooooooooooo.baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
  baaaz,
  quuuuux => {
    let a = 1
    let b = 2
    a + b
  },
)

let make = (arr, ~compare) => {
  let rbt = make(~compare)
  array->Js.Array2.forEach(((value, height)) =>
    add(rbt, value, ~height)->ignore
  )
  rbt
}

"
`;

exports[`constant.js 1`] = `
"let x = 1

let x = 3.14

let x = \\"mystring\\"

let x = @attr 1
let x = @attr 3.14
let x = @attr \\"mystring\\"

"
`;

exports[`constraint.js 1`] = `
"let x = (Numbers.ten: int)

let x = (@attr 10: int)
let x = (@attr 10: int)

let x = (street[\\"number\\"]: int)
let x = (streets[0]: int)

let x = (true ? 1 : 0: int)

"
`;

exports[`constructor.js 1`] = `
"let x = true
let y = false

let r = Reducer()
let r = Reducer(state, nexState, sideEffect)
let r = Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)
let r = Reducer([state, nexState, sideEffect])
let r = Reducer([
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
])

let r = Reducer({state: nextState, sideEffects: []})

let c = Constr({
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
})

let forceBreak = Cartesian({
  x: Omega.x,
  y: Theta.y,
})

let c = Constr(list[
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
])

let c = Constr(list[
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
])

let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer([])
let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer(list[])

let coordinate = JsCoord({\\"x\\": 1, \\"y\\": 1})
let user = JsUser({
  \\"name\\": \\"steve\\",
  \\"age\\": 32,
})

let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      // this shouldn't break over multiple lines
      Some(node)
    } else {
      node.left->peekMinNode
    }
  }

let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      // this shouldn't break over multiple lines
      MyConstructor(
        node,
        nodeLongIdentifiiiiieeeeeeer1,
        nodeLongIdentifiiiiieeeeeeer2,
      )
    } else {
      node.left->peekMinNode
    }
  }

let constructor = @attr Blue

let x = switch x {
| Bar =>
  ReasonReact.UpdateWithSideEffects(
    self => {
      let _ = 1
      apply(bar)
    },
  )
| Foo => ()
}

"
`;

exports[`extension.js 1`] = `
"let x = %eval
let node = %bs.raw(\\"0\\")
let node = %bs.raw(@attr (\\"0\\"))
let node = %bs.raw(@attrStructureLvl (@attrOnExpr \\"0\\"))

let node = %bs.raw(
  @attrStructureLvl @attrStructureLvl2 @attrStructureLvl3
  (@attrOnExpr \\"0\\")
)
let node = %bs.raw(
  @attrStructureLvl @attrStructureLvl2 @attrStructureLvl3
  (
    @attrOnExpr @attrOnExpr2 @attrOnExpr3 @attrOnExpr4 @attrOnExpr5
    \\"unsafe raw js\\"
  )
)
let f: (int, int) => int = %raw((a, b) => \\"{return a + b}\\")

let f = (x, y) => {
  %debugger
  x + y
}

switch %external(__DEV__) {
| Some(_) => Js.log(\\"dev mode\\")
| None => Js.log(\\"production mode\\")
}

let node = @attr %bs.raw(\\"0\\")

"
`;

exports[`field.js 1`] = `
"let n = user.name

(currentNode.parent->castNotOption).color
(&myRef).color
&myRef.intValue
&myRef.intValue

let x = -a.bar

let x = true.x
let x = (12: int).x
let x = list[1, 2, ...x].x
let x = module(Foo: Bar).x
let x = module(Foo).x
let x = Rgb(1, 2, 3).x
let x = [a, b, c].x
let x = {x: 1, y: 3}.x
let x = (1, 2, 3).x
let x = %extension.x
let x = user.name.last
let x = streets[0].house
let x = apply(arg1, arg2).field
let x = apply(. arg1, arg2).field
let x = -1.x
let x = (!true).x
let x = (x => print(x)).x
let x = (
  switch x {
  | Blue => ()
  | Yello => ()
  }
).x

let x = (
  for i in 0 to 10 {
    print_int(i)
  }
).x

let x = (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
).x

let x = (
  while i < 10 {
    print_int(i)
  }
).x

let x = (assert false).x
let x = (lazy false).x
let x = (
  try sideEffect() catch {
  | Exit => ()
  }
).x

let x = (@attr expr).x

let x = (a + b).x

let x = @attr user.name
let x = (isLeft ? node.left : node.right).color
let x = (@attrOnTernary (isLeft ? node.left : node.right)).color

"
`;

exports[`firstClassModule.js 1`] = `
"module(Three)
module(Three: X_int)

let three = module(Three: X_int)
let three = module(Three)

let x = @attr module(Foo)
let x = @attr module(Foo: FirstClass)

"
`;

exports[`for.js 1`] = `
"let () = for i in 0 to 10 {
  ()
}

for i in 0 to 10 {
  let a = 1
  let b = 2
  sideEffect()
}

let x =
  @attr
  for i in 0 to 10 {
    ()
  }

"
`;

exports[`fun.js 1`] = `
"let f = (a, b) => ()
let greet = (~person, ~from as hometown) => ()
let greet = (~person=\\"Steve\\", ~from as hometown=\\"Cupertino\\") => ()

let onChangedVisible = (
  ~anchor=None,
  rbt,
  ~oldNewVisible,
  ~top as top_,
  ~bottom as bottom_,
  ~appear,
  ~remained,
  ~disappear,
) => ()

let greet = (~person, ~from as hometown) =>
  superLongIdentifiiiiiieeeeeeerExpression()

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => superLongIdentifiiiiiieeeeeeerExpression()

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  superLongIdentislkdjflksjdfljslkjdflksjdklfjlskdjfklffiiiiiieeeeeeerExpression()

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => superLongIdentier

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  superLongIdentislkdjflksjdfljslkjdflksjdklfjlskdjfklffiiiiiieeeeeeerExpression

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => SuperLongConstructorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  SuperLongConstructorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr

let f = () => ()
let f = a => ()
let f = _ => ()

let f = (~a=?) => ()
let f = (~from as hometown=?) => ()

let f = (. a) => ()
let f = (. a, b) => ()
let f = (. ()) => ()

let f = @attr (a, b) => @attr2 (c, d) => ()
let f = @attr (@attrOnA a, @attrOnB b) => @attr2 (@attrOnC c, @attrOnD d) => ()
let f = @attr (. a, b) => @attr2 (. c, d) => ()

let f = (@attr ~a, @attr ~b) => ()
let f = (. @attr ~a, . @attr ~b) => ()

let f = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => ()

let coordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {x: 1, y: 2}

let coordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {x: 1, y: 2}

let recordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {
  ...fields,
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}

let arrayBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => [1, 2, 3, 4]

let arrayBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => [
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
]

let tupleBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => (1, 2, 3)

let tupleBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => (
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)

let constrBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => Cartesian({
  x: Omega.x,
  y: Theta.y,
})

let constrBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)

let genName = () => \\"Steve\\"

@react.component
let make = (
  ~onChange as onChange: option<(. {\\"testing\\": bool}, array<string>) => unit>=?,
  children,
) => {
  let doSomething = () =>
    switch onChange {
    | None => ()
    | Some(onChange) => onChange(. {\\"testing\\": true}, [\\"hey\\"])
    }
  <input onChange={_ => doSomething()} />
}

let add = (a, b): int => a + b

let add = (a, b): {
  \\"field1\\": int,
  \\"field2\\": string,
  \\"field3\\": int,
  \\"field4\\": int,
} => a + b
let add = (
  superLongParameterName1,
  superLongParameterName2,
  superLongParameterName3,
): {\\"field1\\": int, \\"field2\\": string, \\"field3\\": int, \\"field4\\": int} => a + b

let add = (
  superLongParameterName1,
  superLongParameterName2,
  superLongParameterName3,
): {
  \\"field1\\": int,
  \\"field2\\": string,
  \\"field3\\": int,
  \\"field4\\": int,
  \\"field5\\": int,
} => a + b

let add = ((a, b)): (int, string, int, int) => a + b
let add = ((a, b)): (
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
) => a + b
let add = ((
  superLongParameterName,
  bsuperLongParameterName,
  superLongParameterName,
  superLongParameterName,
)): (
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
) => a + b

let add = (list[a, b]): list<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b
let add = (list[
  superLongParameterName,
  bsuperLongParameterName,
  superLongParameterName,
  superLongParameterName,
]): list<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b

let add = ([a, b]): array<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b
let add = ([
  superLongParameterName,
  bsuperLongParameterName,
  superLongParameterName,
  superLongParameterName,
]): array<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b

let add = ({
  x: superLongParameterName,
  y: superLongParameterName,
  z: superLongParameterName,
}) => x + y + z
let add = ({
  x: x as superLongParameterName,
  y: y as superLongParameterName,
  z: z as superLongParameterName,
}) => x + y + z

let add = (Color(
  superLongParameterName,
  superLongParameterName,
  superLongParameterNameeeeeee,
)) => x + y + z
let add = (Color(
  superLongParameterName,
  superLongParameterName,
  superLongParameterNameeeee,
)): color<
  superLongTypeIdent,
  superLongType2,
  anotherLongOne,
  woooooooooooooooooooooooooooooooooooow,
> => x + y + z

let parseExceptionDef = (~attrs, p) => {
  let startPos = p.Parser.startPos
  Parser.expect(Token.Exception, p)
  let (_, name, kind) = parseConstrDef(~parseAttrs=false, p)
  let loc = mkLoc(startPos, p.prevEndPos)
  Ast_helper.Te.constructor(~loc, ~attrs, name, kind)
}

and parseStructure = (p): Parsetree.structure =>
  parseList(p, ~grammar=Grammar.Structure, ~f=parseStructureItem)

and parseStructureItem = (_): Parsetree.structure_item => {
  let startPos = p.Parser.startPos
  let attrs = parseAttributes(p)
  attrs
}

// block expressions should have braces on the same line as the =>
let equals = (c1, c2) => {
  open Float
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

let equals2 = (c1, c2) => {
  module B = Belt
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

let equals3 = (c1, c2) => {
  let a = 1
  let b = 2
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

let equals4 = (c1, c2) => {
  exception Foo
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

"
`;

exports[`ident.js 1`] = `
"let x = a

let c = Configuration.config

let x = @attr identifier

let x =
  @attributeVeryLong @attributeVeryLong @attributeVeryLong @attributeVeryLong
  identifier

"
`;

exports[`if.js 1`] = `
"let name = if true {
  user.name
}

let name = if true {
  user.name
} else {
  \\"steve\\"
}

let name = if true {
  user.name
} else if false {
  user.lastName
} else {
  defaultName
}

let () = if true {
  let a = 1
  let b = 2
  open Belt
  sideEffect()
  ()
} else {
  let a = 5
  let b = 6
  open React
  render()
  ()
}

let x =
  @attr
  if truth {
    sideEffect()
  }

"
`;

exports[`jsObjectAccess.js 1`] = `
"let x = address[\\"street\\"]
let x = address[\\"street\\"][\\"number\\"]
let x = @attr address[\\"street\\"]

longEqualityExpression[\\"someRecordField\\"] ==
  wowThisDoesHaveToBePrettyLong[\\"someRecordField\\"] &&
  longEqualityExpression[\\"someRecordField\\"] ==
    wowThisDoesHaveToBePrettyLong[\\"someRecordField\\"]

"
`;

exports[`jsObjectSet.js 1`] = `
"address[\\"street\\"] = \\"Brusselsestraat\\"
address[\\"street\\"] = newYork |> getExpensiveStreet

let () = @attr address[\\"street\\"] = \\"Brusselsestraat\\"
let () = node[\\"left\\"] = value |> process |> node[\\"right\\"] = value |> process
let () = (node[\\"left\\"] = value |> process) |> node[\\"right\\"] = value |> process

"
`;

exports[`jsx.js 1`] = `
"let x =
  <div
    className=\\"container\\"
    className2=\\"container2\\"
    className3=\\"container3\\"
    onClick
  />
let x = <Foo className=\\"container\\" />
let x = <Foo.Bar className=\\"container\\" />
let x = <Foo.Bar.Baz className=\\"container\\" />

let x =
  <div
    className=\\"container\\"
    className2=\\"container2\\"
    className3=\\"container3\\"
    onClick
  />

let nav =
  <Nav isMobile fullScreen={!isMobile ? false : isOpen}>
    <NavContent>
      <WidescreenMenu
        menuItems=props.items
        trial=props.trial
        user=props.user
        viewer=props.viewer
      />
    </NavContent>
  </Nav>

let nav2 =
  <Nav isMobile fullScreen={!isMobile ? false : isOpen}>
    <NavContent>
      {switch isMobile {
      | true =>
        <MobileMenu
          handleOpenToggle={_ =>
            setOpen(open_ => !open_)}
          menuItems=props.items
          isOpen
          forceOpen={_ => setOpen(true)}
          forceClose={_ => setOpen(false)}
          user=props.user
        />
      | false =>
        <WidescreenMenu
          menuItems=props.items
          trial=props.trial
          user=props.user
          viewer=props.viewer
        />
      }}
    </NavContent>
  </Nav>

let nav3 =
  <Nav isMobile fullScreen={!isMobile ? false : isOpen}>
    <NavContent>
      {isMobile
        ? <MobileMenu
            handleOpenToggle={_ =>
              setOpen(open_ => !open_)}
            menuItems=props.items
            isOpen
            forceOpen={_ => setOpen(true)}
            forceClose={_ => setOpen(false)}
            user=props.user
          />
        : <WidescreenMenu
            menuItems=props.items
            trial=props.trial
            user=props.user
            viewer=props.viewer
          />}
    </NavContent>
  </Nav>

let avatarSection =
  <>
    <div style={\\"zIndex\\": \\"1\\", \\"opacity\\": opacityUser}>
      <Avatar user size=45 />
    </div>
    {user.email !== viewer.email
      ? <div
          style={
            \\"marginLeft\\": marginLeft + \\"em\\",
            \\"opacity\\": opacityAdmin,
            \\"zIndex\\": \\"0\\",
            \\"cursor\\": \\"pointer\\",
          }
          onMouseEnter={_ => setHoveringAdmin(true)}
          onMouseLeave={_ => setHoveringAdmin(false)}
          onClick={_e => stopImpersonating(csrfToken)}>
          <Avatar user=viewer size=45 />
        </div>
      : React.nullElement}
  </>

let x = <> </>

let x =
  <div
    ident // punned
    ?ident // punned optional
    ident=?identifierExpr
    ident=identifierExpr
    constant=\\"constant\\"
    letExpr={
      let a = 1
      let b = 2
      a + b
    }
    onClick={event => handleClick(event)}
    onClick={(event1, event2, event3) => {
      Js.log(\\"debug click\\")
      handleClick(event)
    }}
    onClick={(
      aaaaaaaaaaaaaaarg1,
      aaaaaaaaaaaaaaaaaaaaaaarg2,
      aaaaaaaaaaaaaaarg3,
    ) => {
      sideEffect(aaaaaaaaaaaaaaarg1)
      sideEffect(aaaaaaaaaaaaaaaaaaaaaaarg2)
      sideEffect(aaaaaaaaaaaaaaarg3)
    }}
    apply={myFunction(x)}
    applyWithDot={myFunction(. x)}
    street={streets[0]}
    binary={a + b}
    int={-1}
    float={-1.2}
    unary={&myRef}
    matchExpression={switch color {
    | Blue => \\"blue\\"
    | Red => \\"red\\"
    }}
    tryExpression={try sideEffect() catch {
    | Error => ()
    }}
    tuple=(a, b, c)
    constr=Rgb(red, blue, green)
    list1=list[]
    list2=list[a, b]
    list3=list[a, b, ...x]
    array=[a, b, c]
    record={x: 1, y: 2}
    field=foo.bar
    setField={user.name = \\"Steve\\"}
    ifThenElse={if true {
      ()
    } else {
      ()
    }}
    seq={
      sideEffect1()
      sideEffect2()
    }
    whileExpr={while true {
      loop()
    }}
    forExpr={for i in 0 to 10 {
      do(i)
    }}
    constraintExpr={20: int}
    letModule={
      module L = Log
      L.log()
    }
    letException={
      exception Exit
      raise(Exit)
    }
    lazyExpr={lazy stuff()}
    assertExpr={assert true}
    pack=module(Foo)
    pack=module(Foo: Bar)
    openExpr={
      open React
      React.render()
    }
    extension=%bs.raw(\\"eval()\\")
    jsObject={\\"x\\": 1, \\"y\\": 2}
    withAttr={@attr foo}
  />

let x =
  <div>
    ident
    \\"constant\\"
    {
      let a = 1
      let b = 2
      a + b
    }
    {event => handleClick(event)}
    {(event1, event2, event3) => {
      Js.log(\\"debug click\\")
      handleClick(event)
    }}
    {(aaaaaaaaaaaaaaarg1, aaaaaaaaaaaaaaaaaaaaaaarg2, aaaaaaaaaaaaaaarg3) => {
      sideEffect(aaaaaaaaaaaaaaarg1)
      sideEffect(aaaaaaaaaaaaaaaaaaaaaaarg2)
      sideEffect(aaaaaaaaaaaaaaarg3)
    }}
    {myFunction(x)}
    {myFunction(. x)}
    {streets[0]}
    {a + b}
    {-1}
    {-1.2}
    {&myRef}
    {switch color {
    | Blue => \\"blue\\"
    | Red => \\"red\\"
    }}
    {try sideEffect() catch {
    | Error => ()
    }}
    {(a, b, c)}
    Rgb(red, blue, green)
    list[]
    list[a, b]
    list[a, b, ...x]
    [a, b, c]
    {x: 1, y: 2}
    foo.bar
    {user.name = \\"Steve\\"}
    {if true {
      ()
    } else {
      ()
    }}
    {
      sideEffect1()
      sideEffect2()
    }
    {while true {
      loop()
    }}
    {for i in 0 to 10 {
      do(i)
    }}
    {20: int}
    {
      module L = Log
      L.log()
    }
    {
      exception Exit
      raise(Exit)
    }
    {lazy stuff()}
    {assert true}
    module(Foo)
    module(Foo: Bar)
    {
      open React
      React.render()
    }
    %bs.raw(\\"eval()\\")
    {\\"x\\": 1, \\"y\\": 2}
    {@attr ident}
  </div>

let x = <MyComponent sidebar={<div> test </div>} nav={<Navbar />} />

"
`;

exports[`lazy.js 1`] = `
"let x = lazy sideEffect

// parens
let x = lazy true
let x = lazy 12
let x = lazy (12: int)
let x = lazy 12
let x = lazy list[1, 2, ...x]
let x = lazy module(Foo: Bar)
let x = lazy module(Foo)
let x = lazy Rgb(1, 2, 3)
let x = lazy [a, b, c]
let x = lazy {x: 1, y: 3}
let x = lazy (1, 2, 3)
let x = lazy %extension
let x = lazy user.name
let x = lazy streets[0]
let x = lazy apply(arg1, arg2)
let x = lazy apply(. arg1, arg2)
let x = lazy -1
let x = lazy !true
let x = lazy (x => print(x))
let x = lazy (
  switch x {
  | Blue => ()
  | Yello => ()
  }
)

let x = lazy (
  for i in 0 to 10 {
    print_int(i)
  }
)

let x = lazy (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
)

let x = lazy (
  while i < 10 {
    print_int(i)
  }
)

let x = lazy (assert false)
let x = lazy (
  try sideEffect() catch {
  | Exit => ()
  }
)

let x = lazy (@attr expr)

let x = lazy (a + b)

let x = @attr lazy x

let x = lazy street[\\"number\\"]
let x = lazy streets[0]

lazy address[\\"street\\"] = \\"Brusselsestraat\\"

lazy (true ? 0 : 1)

"
`;

exports[`let.js 1`] = `
"let z = {
  let a = 1
  a
}

let x = {
  let x = 1 and y = 2 and z = 3
  
  let x = 1
  and y = 2
  and z = 3
  
  let x = 1
  
  and y = 2
  
  and z = 3
  
  x + y + z
}

let x = {
  let a = true
  let b = false
  a || b
}

"
`;

exports[`letexception.js 1`] = `
"let x = {
  exception Foo
  sideEffect
}

"
`;

exports[`letmodule.js 1`] = `
"let x = {
  module M = ME
  Me.x
}

"
`;

exports[`list.js 1`] = `
"let x = list[]
let x = list[1]
let x = list[1, 2]
let x = list[1, 2, 3]

let x = list[
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
]

let x = list[1, ...otherList]

let x = list[
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
]

"
`;

exports[`newtype.js 1`] = `
"let f = (type t, xs: list<t>) => ()
let f = (@attr type t, xs: list<t>) => ()
let f = (type t, xs: list<t>, type s, ys: list<s>) => ()
let f = (@attr type t, xs: list<t>, @attr2 type s, ys: list<s>) => ()
let f = (type t u v, xs: list<(t, u, v)>) => ()
let f = (@attr type t u v, xs: list<(t, u, v)>) => ()
let f = (type t u v, xs: list<(t, u, v)>, type s w z, ys: list<(s, w, z)>) => ()
let f = (
  @attr type t u v,
  xs: list<(t, u, v)>,
  @attr2 type s w z,
  ys: list<(s, w, z)>,
) => ()
let f = (
  @attr type t,
  @attr type s,
  xs: list<(t, s)>,
  @attr type u,
  @attr type v w,
  ys: list<(u, v, w)>,
) => ()

"
`;

exports[`open.js 1`] = `
"let element = {
  open React
  element
}

let element = {
  open! React
  element
}

"
`;

exports[`record.js 1`] = `
"let coord = {x: 3.13, y: 3.14}
let record = {
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}

let forceBreak = {
  x: Omega.x,
  y: Theta.y,
}

let withSpread = {...initialState, time: nextTime}
let withSpreadAndForceBreak = {
  ...initialState,
  time: nextTime,
}

let withSpreadAndNaturalBreak = {
  ...fields,
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}

let x = @attr {x: 1, y: 2}
let x =
  @attr {...initialState, superLongName: 1, superLongName: 2, superLongName: 5}
let x =
  @attr
  {
    ...initialState,
    superLongName: 1,
    superLongName: 2,
    superLongName: 5,
    superLongName: 20,
  }

"
`;

exports[`sequence.js 1`] = `
"let () = {
  foo()
  bar()
}

let () = {
  (foo(): unit)
  (bar(): unit)
}

"
`;

exports[`setfield.js 1`] = `
"user.name = \\"steve\\"
config.shouldSkip =
  !filePath.includes(allMlSuffixesCategory) &&
  !filePath.endsWith(allScriptDirectoriesCategory)

let () = @attr user.name = \\"steve\\"

let () = @attr user.name = \\"steve\\" |> @attr user.name = \\"steve\\"

user.name = steve[\\"name\\"]
user.address = addresses[2]

(currentNode.parent->castNotOption).color = Black
(isLeft ? node.left : node.right).color = Black

"
`;

exports[`sideEffects.js 1`] = `
"foo()
bar()

let () = {
  foo()
  bar()
}

let () = {
  let x = 1
  sideEffect()
  let y = 2
  sideEffect2()
  let z = 3
  sideEffect3()
}

while true {
  sideEffect1()
  let x = 1
  sideEffect2()
  let y = 2
  sideEffect3()
}

switch color {
| Blue =>
  getResult()
  sideEffect()
  let x = 1
  sideEffect2()
}

"
`;

exports[`switch.js 1`] = `
"switch x {
| A => ()
| B => ()
}

switch (a, b) {
| (Some(a), Some(b)) => 42
| _ => 3
}

let rec updateSum = (node, ~delta) =>
  switch node {
  | None => ()
  | Some(node) =>
    node.sum = node.sum +. delta
    node.parent->updateSum(~delta)
  }

let x =
  @attr
  switch x {
  | Universe => ()
  }

"
`;

exports[`ternary.js 1`] = `
"condition1 ? value1 : value2

let x = condition1 ? value1 : value2

let value = condition1
  ? value1
  : condition2
  ? value2
  : condition3
  ? value3
  : value4

let paymentMessage = condition
  ? \\"Payment completed successfully\\"
  : state == \\"processing\\"
  ? \\"Payment processing\\"
  : state == \\"invalid_cvc\\"
  ? \\"There was an issue with your CVC number\\"
  : state == \\"invalid_expiry\\"
  ? \\"Expiry must be sometime in the past.\\"
  : \\"There was an issue with the payment.  Please contact support.\\"

let paymentMessage =
  state == \\"success\\"
    ? \\"Payment completed successfully\\"
    : state == \\"processing\\"
    ? \\"Payment processing\\"
    : state == \\"invalid_cvc\\"
    ? \\"There was an issue with your CVC number\\"
    : state == \\"invalid_expiry\\"
    ? \\"Expiry must be sometime in the past.\\"
    : \\"There was an issue with the payment.  Please contact support.\\"

let record = truth ? {x: 1, y: 2} : {x: 3, y: 5}
let record = truth
  ? {
      thisIsASuperLongFieldHere: loooooooooooooongIdentifier,
      anotherLongField: superLoooooooooooooooooongIdentifier,
    }
  : {
      thisIsASuperLongFieldHere: loooooooooooooongIdentifier,
      anotherLongField: superLoooooooooooooooooongIdentifier,
    }

let arr = truth ? [1, 2, 3, 4] : [4, 5, 6, 7]
let arr = truth
  ? [
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    ]
  : [
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    ]

let lst = truth ? list[1, 2, 3, 4] : list[4, 5, 6, 7]
let lst = truth
  ? list[
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    ]
  : list[
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    ]

let construct = truth ? Constructor(1, 2, 3, 4) : Constructor(4, 5, 6, 7)
let construct = truth
  ? Constructor(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : Constructor(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )

let x = truth
  ? {
      let a = 1
      let b = 2
      a + b
    }
  : {
      let a = 1
      let b = 2
      a + b
    }
let x = truth
  ? {
      let a = 1
      let b = 2
      a + b
    }
  : {
      let a = 1
      let b = 2
      a + b
    }

let x = truth ? create(a, b) : create(b, c)
let x = truth
  ? create(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : create(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
let x = truth ? create(. a, b) : create(. b, c)
let x = truth
  ? create(.
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : create(.
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )

let street = newYork ? streets[0] : streets[20]
let street = newYork
  ? thisIsASuperLongIdentifieeeeeeeer[0]
  : thisIsASuperLongIdentifieeeeeeeer[20]

let x = isNegative ? -x : y
let x = isNegative
  ? -thisIsASuperLongIdentifieeeeeeeer
  : &thisIsASuperLongIdentifieeeeeeeer

let x = isGreater ? a + b : z - c
let x = isGreater
  ? thisIsASuperLongIdentifieeeeeeeer + 20
  : thisIsASuperLongIdentifieeeeeeeer + 200

let x = isColor
  ? switch color {
    | Blue => ()
    | Red => ()
    }
  : switch color {
    | Blue => ()
    | Red => ()
    }

let x = exceptionLike
  ? try dangerousThing() catch {
    | Exit => ()
    }
  : try dangerousThing() catch {
    | Exit => ()
    }

let tuple = truth ? (1, 2, 3, 4) : (4, 5, 6, 7)
let tuple = truth
  ? (
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : (
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )

let x = condition1 ? node.left : node.right
let x = condition1
  ? nodeWithVeryLooooooooooooooooongNameHere.left
  : nodeWithVeryLooooooooooooooooongNameHere.right

let x = condition ? node.left = Some(newNode) : node.right = Some(newNode)
let x = condition1
  ? nodeWithVeryLooooooooooooooooongNameHere.left = Some(newNode)
  : nodeWithVeryLooooooooooooooooongNameHere.right = Some(newNode)

let x = condition1
  ? if true {
      ()
    } else {
      ()
    }
  : if true {
      ()
    } else {
      ()
    }
let () = condition1
  ? {
      sideEffect()
      sideEffect2()
    }
  : {
      sideEffect()
      sideEffect2()
    }

let () = condition1
  ? while true {
      doThing()
    }
  : while true {
      doOtherThing()
    }
let () = condition1
  ? for i in 0 to 10 {
      ()
    }
  : for i in 10 to 20 {
      ()
    }

let () = (truth: bool) ? (10: int) : (20: int)

let () = condition
  ? {
      module L = Logger
      L.log()
    }
  : {
      exception Exit
      raise(Exit)
    }
let () = condition ? lazy foo() : assert false

let x = condition ? module(Foo) : module(Int: Number)
let x = condition
  ? module(ModuleWithVeryLooooooooooooooooongNameHere)
  : module(ModuleWithVeryLooooooooooooooooongNameHereInt: Number)

let x = condition
  ? {
      open React
      render()
    }
  : {
      open React
      render()
    }
let x = condition ? %eval(\\"console.log\\") : %eval(\\"console.err\\")
let x = condition
  ? %eval(\\"consoooooooooooooooooooooole.log\\")
  : %eval(\\"consoleeeeeeeeeeeeeee.err\\")

let jsObj = condition ? {\\"x\\": 1, \\"y\\": 2} : {\\"x\\": 20, \\"y\\": 100}
let jsObj = truth
  ? {
      \\"thisIsASuperLongFieldHere\\": loooooooooooooongIdentifier,
      \\"anotherLongField\\": superLoooooooooooooooooongIdentifier,
    }
  : {
      \\"thisIsASuperLongFieldHere\\": loooooooooooooongIdentifier,
      \\"anotherLongField\\": superLoooooooooooooooooongIdentifier,
    }

let f = isPositive ? x => x + 1 : y => y - 1
let f = isPositive ? ((a, b): int => a + b) : ((c, d): int => c - d)
let f = isPositive ? ((a, b): int => a + b) : ((c, d): int => c - d)

a => a ? () => a : () => a
a => a ? a : a
a =>
  a ? aasdasdasdasdasdasdaaasdasdasdasdasdasdasdasdasdasdasdasdasdaaaaaaaaa : a

let x = @attrOnTernary (truth ? true : false)
let x = @attrOnCondition truth ? true : false

"
`;

exports[`try.js 1`] = `
"try {
  let x = 1
  let y = 2
  dangerousCall()
} catch {
| Foo => Js.log()
| Exit => Js.log()
}

try myDangerousFn() catch {
| Foo => Js.log()
}

let x = {
  let y = 1
  try apply() catch {
  | _ => 2
  }
}

@attr @attr2
try myDangerousFn() catch {
| Foo => Js.log()
}

let () =
  @attr @attr2
  try myDangerousFn() catch {
  | Foo => Js.log()
  }

"
`;

exports[`tuple.js 1`] = `
"let x = (1, 2, 3)

let x = (
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
)

let x =
  @attr
  (
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
  )

"
`;

exports[`unary.js 1`] = `
"let x = -a
let x = -.a
let x = !a
let x = &a

let isMale = !user[\\"female\\"]
let stuff = &addressRefs[0]

!(!a)
!(!(!a))
!(a |> f(b))

-1->add
-1->add
-(1->add)
!foo->print_bool
!foo->print_bool
!(foo->parseTruth)

node.left->peekMinNode
// same as the above
node.left->peekMinNode

// field access has higher precedence than unary -
let x = -a.bar
// same as above
let x = -a.bar

!(lazy x)
lazy !x
!(assert x)
assert !x
!(@attr expr)
!(arg => doStuffWith(arg))
let x = !(truth: bool)
let x = (!truth: bool)

let z = !(%extension)
&(x.left = value)
&(x.left = value)
// (!x.left) = value -> this does not parse, lhs of Pexp_setfield can't be a unary expression?
-[a, b, c]
!module(Foo: Bar)
!module(Foo)
let x = -apply(arg)
let x = -apply(. arg)
let x = -Foo(a, b, c)
let x = -{x: 1, y: 2}
let x = -list[1, 2, 3]
let x = -(
  if true {
    1
  } else {
    2
  }
)
let x = -(
  for i in 0 to 10 {
    ()
  }
)
let x = -(
  switch x {
  | Foo => 1
  }
)
let x = -(
  while i < 10 {
    i.contents = 20
  }
)
let x = -(1, 2, 3)
let x = -{
  let a = 1
  let b = 2
  a + b
}
let x = -{
  sideEffect()
  generateNumber()
}

-(true ? 0 : 1)

let () = {
  getResult()
  -10
}

"
`;

exports[`while.js 1`] = `
"let () = while true {
  ()
}

while true {
  let a = 1
  let b = 2
  infiniteLoop()
  ()
}

// adds parens when condition breaks over multiple lines
while (
  continuePrefix.contents &&
  aPrefixLen.contents <= aLen &&
  bPrefixLen.contents <= bLen
) {
  let nextNonwhiteA = nextNonWhiteChar(aStr, 1, aPrefixLen.contents - 1)
  let nextNonwhiteB = nextNonWhiteChar(bStr, 1, bPrefixLen.contents - 1)
  ()
}

let x =
  @attr
  while true {
    break()
  }

"
`;

exports[`whitespace.js 1`] = `
"let x = {
  let a = 1
  let b = 2
  sideEffect()
  sideEffect2()
}

let x = {
  let a = 1
  
  let b = 2
  
  a + b
}

let x = {
  exception Exit
  
  exception Terminate
  
  module B = Belt
  
  sideEffect()
  
  open React
  
  sideEffect2()
}

let x = {
  exception Exit
  exception Terminate
  module B = Belt
  sideEffect()
  open React
  sideEffect2()
}

"
`;
