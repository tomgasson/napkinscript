// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`apply.js 1`] = `
"console.log()
Js.log(\\"arg1\\", \\"arg2\\")
let rbt = make(~compare)
let rbt = make(~compare?)
let rbt = make(~compare=intCompare)
let rbt = make(~compare=?intCompare)
let rbt = make(~compare=?intCompare: (int, int) => int)
let () = applyFunctionToArguments(
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
)
let cmp = rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value)
let cmp = rbt.compare2(.
  Js.Array2.unsafe_get(old, oldIter.contents),
  longerNode.longValue,
)
let uncurriedUnit = apply(.)
let coordinate = make2dCoordinate({x: 1, y: 2})
let coordinate = make3dCoordinate({
  ...base,
  field1: thisIsAPrettyLongNameHere,
  field2: thisIsAPrettyLongNameHere,
  field3: thisIsAPrettyLongNameHere,
})
let coordinate = make2dCoordinateArray([x, y])
let coordinate = make3dCoordinateArray([
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
])
let coordinate = make2dCoordinateTuple(/x, y/)
let coordinate = make3dCoordinateTuple(/
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
/)
let coordinate = make2dCoordinateList(list(x, y))
let coordinate = make3dCoordinateList(list(
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  ...allCoords,
))
let coordinate = makeJsCoordinate({\\"x\\": 1, \\"y\\": 1})
let user = makeJsUser({
  \\"name\\": \\"steve\\",
  \\"age\\": 32,
})

"
`;

exports[`array.js 1`] = `
"let x = []
let x = [a, b, c]
let x = [
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
]

"
`;

exports[`assert.js 1`] = `
"assert false
assert truth
let x = assert true
let x = assert 12
let x = assert (12: int)
let x = assert 12
let x = assert list(1, 2, ...x)
let x = assert module(Foo: Bar)
let x = assert module(Foo)
let x = assert Rgb(1, 2, 3)
let x = assert [a, b, c]
let x = assert {x: 1, y: 3}
let x = assert /1, 2, 3/
let x = assert %extension
let x = assert user.name
let x = assert (Array.get(streets, 0))
let x = assert (apply(arg1, arg2))
let x = assert -1
let x = assert !true
let x = assert (x => print(x))
let x = assert (
  switch x {
  | Blue => ()
  | Yello => ()
  }
)
let x = assert (
  for i in 0 to 10 {
    print_int(i)
  }
)
let x = assert (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
)
let x = assert (
  while i < 10 {
    print_int(i)
  }
)
let x = assert (lazy false)
let x = assert (
  try sideEffect() catch {
  | Exit => ()
  }
)
let x = assert (@attr expr)
let x = assert (a + b)

"
`;

exports[`binary.js 1`] = `
"let x = a && b + c
let x = (a && b) + c
let x = (a && b) || c
let x = (a && b) + (c && d)
while (
  continuePrefix.contents &&
  aPrefixLen.contents &&
  bPrefixLen.contents &&
  foobarLen.contents
) {
  ()
}
while (
  rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value) < 0
) {
  ()
}
let x =
  !filePath.includes(allMlSuffixesCategory) &&
  !filePath.endsWith(allScriptDirectoriesCategory)
let x = foo ++ bar
let x = foo != bar
let x = foo !== bar
let x = foo ++ bar
let x = 1 + 1
let x = (a => a + 1) + (b => b + 2)
let x = -1 + -1
let x =
  switch z {
  | Red => 1
  }
  |> switch y {
  | Blue => 2
  }
let x =
  try z catch {
  | Exit => 1
  }
  |> try y catch {
  | Blue => 2
  }
let x =
  if true {
    1
  } else {
    2
  } +
  if false {
    2
  } else {
    3
  }
let x =
  for i in 0 to 10 {
    ()
  }
  |> for i in 0 to 10 {
    ()
  }
let x = (/a, b/) + (/b, c/)
let x = Vec3(a, b, c) + Vec4(a, b, c, d)
let x = {x: 1, y: 2} + {x: 2, y: 3}
let x = user.firstName ++ user.lastName

"
`;

exports[`block.js 1`] = `
"let x = {
  module Foo = Bar
  exception Exit
  open Belt
  let a = 1
  let b = 2
  sideEffect()
  sideEffect2()
  ()
}

"
`;

exports[`bsObj.js 1`] = `
"let user = {
  \\"name\\": \\"Steve\\",
  \\"age\\": 30,
}
let coord = {\\"x\\": 1, \\"y\\": 2}
let person = {
  \\"name\\": {
    \\"first\\": \\"Bob\\",
    \\"last\\": \\"Zhmith\\",
  },
  \\"age\\": 32,
}

"
`;

exports[`constant.js 1`] = `
"let x = 1
let x = 3.14
let x = \\"mystring\\"

"
`;

exports[`constraint.js 1`] = `
"let x = (Numbers.ten: int)

"
`;

exports[`constructor.js 1`] = `
"let x = true
let y = false
let r = Reducer()
let r = Reducer(state, nexState, sideEffect)
let r = Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)
let r = Reducer([state, nexState, sideEffect])
let r = Reducer([
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
])
let r = Reducer({state: nextState, sideEffects: []})
let c = Constr({
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
})
let forceBreak = Cartesian({
  x: Omega.x,
  y: Theta.y,
})
let c = Constr(list(
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
))
let c = Constr(list(
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
))
let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer([])
let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer(list())
let coordinate = JsCoord({\\"x\\": 1, \\"y\\": 1})
let user = JsUser({
  \\"name\\": \\"steve\\",
  \\"age\\": 32,
})
let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      Some(node)
    } else {
      node.left->peekMinNode
    }
  }
let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      MyConstructor(
        node,
        nodeLongIdentifiiiiieeeeeeer1,
        nodeLongIdentifiiiiieeeeeeer2,
      )
    } else {
      node.left->peekMinNode
    }
  }

"
`;

exports[`extension.js 1`] = `
"let x = %eval

"
`;

exports[`field.js 1`] = `
"let n = user.name
(currentNode.parent->castNotOption).color
(&myRef).color
&myRef.intValue
&myRef.intValue
let x = -a.bar
let x = true.x
let x = 12.
x
let x = (12: int).x
let x = list(1, 2, ...x).x
let x = module(Foo: Bar).x
let x = module(Foo).x
let x = Rgb(1, 2, 3).x
let x = [a, b, c].x
let x = {x: 1, y: 3}.x
let x = /1, 2, 3/.x
let x = %extension.x
let x = user.name.last
let x = Array.get(streets, 0).house
let x = apply(arg1, arg2).field
let x = -1.x
let x = (!true).x
let x = (x => print(x)).x
let x = (
  switch x {
  | Blue => ()
  | Yello => ()
  }
).x
let x = (
  for i in 0 to 10 {
    print_int(i)
  }
).x
let x = (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
).x
let x = (
  while i < 10 {
    print_int(i)
  }
).x
let x = (assert false).x
let x = (lazy false).x
let x = (
  try sideEffect() catch {
  | Exit => ()
  }
).x
let x = (@attr expr).x
let x = (a + b).x

"
`;

exports[`firstClassModule.js 1`] = `
"let three = module(Three: X_int)
let three = module(Three)

"
`;

exports[`for.js 1`] = `
"let () = for i in 0 to 10 {
  ()
}
for i in 0 to 10 {
  let a = 1
  let b = 2
  sideEffect()
}

"
`;

exports[`fun.js 1`] = `
"let f = (a, b) => ()
let greet = (~person, ~from as hometown) => ()
let greet = (~person=\\"Steve\\", ~from as hometown=\\"Cupertino\\") => ()
let onChangedVisible = (
  ~anchor=None,
  rbt,
  ~oldNewVisible,
  ~top as top_,
  ~bottom as bottom_,
  ~appear,
  ~remained,
  ~disappear,
) => ()
let greet = (~person, ~from as hometown) =>
  superLongIdentifiiiiiieeeeeeerExpression()
let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => superLongIdentifiiiiiieeeeeeerExpression()
let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  superLongIdentislkdjflksjdfljslkjdflksjdklfjlskdjfklffiiiiiieeeeeeerExpression()
let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => superLongIdentier
let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  superLongIdentislkdjflksjdfljslkjdflksjdklfjlskdjfklffiiiiiieeeeeeerExpression
let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => SuperLongConstructorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  SuperLongConstructorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
let f = () => ()
let f = a => ()
let f = _ => ()
let f = (~a=?) => ()
let f = (~from as hometown=?) => ()
let f = (. a) => ()
let f = (. a, b) => ()
let f = (. ()) => ()
let f = @attr (a, b) => @attr2 (c, d) => ()
let f = @attr (@attrOnA a, @attrOnB b) => @attr2 (@attrOnC c, @attrOnD d) => ()
let f = @attr (. a, b) => @attr2 (. c, d) => ()
let f = (@attr ~a, @attr ~b) => ()
let f = (. @attr ~a, . @attr ~b) => ()
let f = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => ()
let coordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {x: 1, y: 2}
let coordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {x: 1, y: 2}
let recordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {
  ...fields,
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}
let arrayBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => [1, 2, 3, 4]
let arrayBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => [
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
]
let tupleBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => /1, 2, 3/
let tupleBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => /
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
/
let constrBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => Cartesian({
  x: Omega.x,
  y: Theta.y,
})
let constrBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)
let genName = () => \\"Steve\\"
let make = (
  ~onChange as onChange: option<(. {\\"testing\\": bool}, array<string>) => unit>=?,
  children,
) => {
  let doSomething = () =>
    switch onChange {
    | None => ()
    | Some(onChange) => onChange(. {\\"testing\\": true}, [\\"hey\\"])
    }
  input(~onChange=_ => doSomething(), ~children=list(), ())
}

"
`;

exports[`ident.js 1`] = `
"let x = a
let c = Configuration.config

"
`;

exports[`if.js 1`] = `
"let name = if true {
  user.name
}
let name = if true {
  user.name
} else {
  \\"steve\\"
}
let name = if true {
  user.name
} else if false {
  user.lastName
} else {
  defaultName
}
let () = if true {
  let a = 1
  let b = 2
  open Belt
  sideEffect()
  ()
} else {
  let a = 5
  let b = 6
  open React
  render()
  ()
}

"
`;

exports[`lazy.js 1`] = `
"let x = lazy sideEffect
let x = lazy true
let x = lazy 12
let x = lazy (12: int)
let x = lazy 12
let x = lazy list(1, 2, ...x)
let x = lazy module(Foo: Bar)
let x = lazy module(Foo)
let x = lazy Rgb(1, 2, 3)
let x = lazy [a, b, c]
let x = lazy {x: 1, y: 3}
let x = lazy /1, 2, 3/
let x = lazy %extension
let x = lazy user.name
let x = lazy Array.get(streets, 0)
let x = lazy apply(arg1, arg2)
let x = lazy apply(. arg1, arg2)
let x = lazy -1
let x = lazy !true
let x = lazy (x => print(x))
let x = lazy (
  switch x {
  | Blue => ()
  | Yello => ()
  }
)
let x = lazy (
  for i in 0 to 10 {
    print_int(i)
  }
)
let x = lazy (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
)
let x = lazy (
  while i < 10 {
    print_int(i)
  }
)
let x = lazy (assert false)
let x = lazy (
  try sideEffect() catch {
  | Exit => ()
  }
)
let x = lazy (@attr expr)
let x = lazy (a + b)

"
`;

exports[`let.js 1`] = `
"let z = {
  let a = 1
  a
}

"
`;

exports[`letexception.js 1`] = `
"let x = {
  exception Foo
  sideEffect
}

"
`;

exports[`letmodule.js 1`] = `
"let x = {
  module M = ME
  Me.x
}

"
`;

exports[`list.js 1`] = `
"let x = list()
let x = list(1)
let x = list(1, 2)
let x = list(1, 2, 3)
let x = list(
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
)
let x = list(1, ...otherList)
let x = list(
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
)

"
`;

exports[`open.js 1`] = `
"let element = {
  open React
  element
}
let element = {
  open! React
  element
}

"
`;

exports[`record.js 1`] = `
"let coord = {x: 3.13, y: 3.14}
let record = {
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}
let forceBreak = {
  x: Omega.x,
  y: Theta.y,
}
let withSpread = {...initialState, time: nextTime}
let withSpreadAndForceBreak = {
  ...initialState,
  time: nextTime,
}
let withSpreadAndNaturalBreak = {
  ...fields,
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}

"
`;

exports[`sequence.js 1`] = `
"let () = {
  foo()
  bar()
}
let () = {
  (foo(): unit)
  (bar(): unit)
}

"
`;

exports[`setfield.js 1`] = `
"user.name = \\"steve\\"

"
`;

exports[`switch.js 1`] = `
"switch x {
| A => ()
| B => ()
}
switch /a, b/ {
| /Some(a), Some(b)/ => 42
| _ => 3
}

"
`;

exports[`try.js 1`] = `
"try {
  let x = 1
  let y = 2
  dangerousCall()
} catch {
| Foo => Js.log()
| Exit => Js.log()
}
try myDangerousFn() catch {
| Foo => Js.log()
}
let x = {
  let y = 1
  try apply() catch {
  | _ => 2
  }
}

"
`;

exports[`unary.js 1`] = `
"let x = -a
let x = -.a
let x = !a
let x = &a
!(!a)
!(!(!a))
!(a |> f(b))
-1->add
-1->add
-(1->add)
(!foo)->print_bool
(!foo)->print_bool
!(foo->parseTruth)
node.left->peekMinNode
node.left->peekMinNode
let x = -a.bar
let x = -a.bar
!(lazy x)
lazy !x
!(assert x)
assert !x
!(@attr expr)
!(arg => doStuffWith(arg))
let x = !(truth: bool)
let x = (!truth: bool)
let z = !(%extension)
&(x.left = value)
&(x.left = value)
-[a, b, c]
!module(Foo: Bar)
!module(Foo)
let x = -apply(arg)
let x = -apply(. arg)
let x = -Foo(a, b, c)
let x = -{x: 1, y: 2}
let x = -list(1, 2, 3)
let x = -(
  if true {
    1
  } else {
    2
  }
)
let x = -(
  for i in 0 to 10 {
    ()
  }
)
let x = -(
  switch x {
  | Foo => 1
  }
)
let x = -(
  while i < 10 {
    i.contents = 20
  }
)
let x = -/1, 2, 3/
let x = -{
  let a = 1
  let b = 2
  a + b
}
let x = -{
  sideEffect()
  generateNumber()
}

"
`;

exports[`while.js 1`] = `
"let () = while true {
  ()
}
while true {
  let a = 1
  let b = 2
  infiniteLoop()
  ()
}
while (
  continuePrefix.contents &&
  aPrefixLen.contents <= aLen &&
  bPrefixLen.contents <= bLen
) {
  let nextNonwhiteA = nextNonWhiteChar(aStr, 1, aPrefixLen.contents - 1)
  let nextNonwhiteB = nextNonWhiteChar(bStr, 1, bPrefixLen.contents - 1)
  ()
}

"
`;
