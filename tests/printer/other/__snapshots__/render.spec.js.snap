// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`StaticReactTypes.js 1`] = `
"type empty = Empty_

type elem<'t> =
  | Empty: elem<empty>
  | Element(renderable<('s, 'a) => 'sub>): elem<('s, 'a) => 'sub>
  | TwoElements(elem<'t1>, elem<'t2>): elem</'t1, 't2/>
  | ElementMap(list<elem<'t>>): elem<list<'t>>

and subtree<'t> =
  | EmptyInstance: subtree<empty>
  | Instance(inst<('s, 'a) => 'sub>): subtree<('s, 'a) => 'sub>
  | TwoInstances(subtree<'t1>, subtree<'t2>): subtree</'t1, 't2/>
  | InstanceMap(list<subtree<'t>>): subtree<list<'t>>
and reducer<'t> = (inst<'t>, 'a) => 's constraint 't = ('s, 'a) => 'sub

and componentSpec<'t> = Reducer('s, elem<'sub>, reducer<'t>)
  constraint 't = ('s, 'a) => 'sub
and self<'t> = {
  reduceEvent: 'e. ('e => 'a, 'e) => unit,
  send: 'a => unit,
} constraint 't = ('s, 'a) => 'sub

and renderable<'t> = (~state: 's=?, self<'t>) => componentSpec<'t>
  constraint 't = ('s, 'a) => 'sub

and inst<'t> = {
  replacer: replacer<'t>,
  subreplacer: subreplacer<'sub>,
  self: self<'t>,
  renderable: renderable<'t>,
  spec: componentSpec<'t>,
  subtree: subtree<'sub>,
} constraint 't = ('s, 'a) => 'sub

and replacer<'t> = inst<'t> => inst<'t> => unit constraint 't = ('s, 'a) => 'sub
and subreplacer<'sub> = subtree<'sub> => subtree<'sub> => unit

"
`;

exports[`case.js 1`] = `
"let printExprFunParameters = (~uncurried, parameters) =>
  switch parameters {
  | list(/[], Asttypes.Nolabel, None, {Parsetree.ppat_desc: Ppat_any}/)
    when !uncurried =>
    Doc.text(\\"_\\")
  | list(/
      [],
      Asttypes.Nolabel,
      None,
      {Parsetree.ppat_desc: Ppat_var(stringLoc)}
    /) when !uncurried =>
    Doc.text(stringLoc.txt)
  | list(/
      [],
      Nolabel,
      None,
      {ppat_desc: Ppat_construct({txt: Longident.Lident(\\"()\\")}, None)}
    /) when !uncurried =>
    Doc.text(\\"()\\")
  | parameters =>
    let lparen = if uncurried {
      Doc.text(\\"(. \\")
    } else {
      Doc.lparen
    }
    let shouldHug = ParsetreeViewer.parametersShouldHug(parameters)
    let printedParamaters = Doc.concat(list(
      if shouldHug {
        Doc.nil
      } else {
        Doc.softLine
      },
      Doc.join(
        ~sep=Doc.concat(list(Doc.comma, Doc.line)),
        List.map(printExpFunParameter, parameters),
      ),
    ))
    Doc.group(
      Doc.concat(list(
        lparen,
        if shouldHug {
          printedParamaters
        } else {
          Doc.indent(printedParamaters)
        },
        if shouldHug {
          Doc.nil
        } else {
          Doc.concat(list(Doc.trailingComma, Doc.softLine))
        },
        Doc.rparen,
      )),
    )
  }

"
`;

exports[`string.js 1`] = `
"let s = \\"a string with \\\\b \\\\n \\\\r \\\\t abcdef\\"

let s = \\"ðŸš€ ðŸ¤­ ðŸ”¥ ðŸ˜€ with emojis ðŸ˜… ðŸ‘Œ test ðŸ‘€\\"

let s = \\"a \\\\\\"string inside\\\\\\" a string\\"

let s = \\"a double escaped \\\\\\\\ test\\"

let s = \\"what happens here \\\\\\\\n\\"

"
`;
