// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`array.js 1`] = `
"let x = [|1;2;3|]
let x = [|1;2;3|]
let x = [|(1 : int);(2 : int);(3 : int)|]
"
`;

exports[`arrow.js 1`] = `
"let f x = x + 1
let f _ = Js.log \\"test\\"
let f () = Js.log \\"unit\\"
let f (Reducer (inst, comp)) = inst.render comp
let f (Instance) = ()
let f a b = a + b
let f 1 2 = ()
let f \\"stringPattern\\" = ()
let f \\"stringPattern\\" \\"stringPattern\\" = ()
let f () = ()
let f (a : int) (b : int) = a + b
let f _ _ = ()
let f [|a;b|] [|c;d|] = ((a + b) + c) + d
let f { a } = a + 1
let f { a; b } { c; d } = ((a + b) + c) + d
let f (a) = a + 1
let f (a, b) = a + b
let f (a, b) (c, d) = ((a + b) + c) + d
let f exception Terminate = ()
let f exception Terminate exception Exit = ()
let f (lazy x) = ()
let f (lazy x) (lazy y) = ()
let f [] = ()
let f (x::xs) = x + (xs |. Belt.List.length)
let f (x : int) (y : int) = x + y
let f ~a  ~b  = a + b
let f ~a:x  ~b:y  = x + y
let f ~a:(x : int)  ~b:(y : int)  = x + y
let f ?(a= 1)  ?(b= 2)  c = (a + b) + c
let f ?a:(x= 1)  ?b:(y= 2)  c = (x + y) + c
let f ?a:((x : int)= 1)  ?b:((y : int)= 2)  c = (x + y) + c
let f ?a  ?b  c =
  match (a, b) with | (Some a, Some b) -> (a + b) + c | _ -> 3
let f ?a:x  ?b:y  c =
  match (x, y) with | (Some a, Some b) -> (a + b) + c | _ -> 3
let f ?a:(x : int option)  ?b:(y : int option)  c =
  match (x, y) with | (Some a, Some b) -> (a + b) + c | _ -> 3
let f a b = a + b
"
`;

exports[`block.js 1`] = `
"let b =
  let module Array = Belt.Array in
    ([|1;2|] |. (Array.map (fun x -> x + 1))) |. Js.log
let b = let open Belt.Array in ([|1;2|] |. (map (fun x -> x + 1))) |. Js.log
let b = let exception QuitEarly  in raise QuitEarly
let b = let a = 1 in let b = 2 in a + b
let b = let _ = sideEffect () in ()
let b = let _ = sideEffect () in ()
let b = a (); b (); c ()
let b = a (); b (); (let a = 1 in f a)
let b = let a = 1 in let b = 2 in ()
let b =
  let module Array = Belt.Array in
    let open Array in
      let exception Terminate of int  in
        let a = 1 in
        let b = 2 in
        sideEffect ();
        (let x = (1 + 2) |. (fun x -> x + 1) in raise (Terminate x))
let b = f (); g (); h (); (let arr = [|1;2;3|] in ())
let res =
  let a = \\"a starts out as\\" in
  (print_string a; (let a = 20 in print_int a)); print_string a
let res =
  let a = \\"first its a string\\" in
  let a = 20 in print_int a; print_int a; print_int a
let res =
  let a = \\"a is always a string\\" in
  print_string a; (let b = 30 in print_int b)
let nestedLet = let _ = 1 () in ()
let nestedLet = let _ = 1 in 2
"
`;

exports[`bracedOrRecord.js 1`] = `
"let r = { expr with pexp_attributes = [||] }
let r = { a }
let r = { a = expr }
let r = { a = expr }
let r = { a = expr; b = expr2 }
let r = { f = (fun x -> x + b) }
let e = a
let e = a
let e = a; b ()
let e = - a
let e = a + b
let e = if a then true else false
let e = if a |> computation then true else false
let e = a.(0)
let e = f b
let e = (a.b).c
let e = arr.(x) <- 20
let e x = (x + 1) |> (doStuff config)
let e = (fun x -> x + 1) |> (doStuff config)
let e = if fun x -> x + 1 then true else false
let e = (fun x -> x + 1) |> sideEffect; logToAnalytics Shady.ml
let f event = (event.target).value
let f event = ((event.target).value : string)
let x = let a = 1 in let b = 2 in a + b
"
`;

exports[`constants.js 1`] = `
"let x = true
let y = false
let txt = \\"a string\\"
let number = 1
let template = \\"amazing\\\\n  multine\\\\n  template\\\\n     string\\\\n\\"
let complexNumber = 1.6
"
`;

exports[`constructor.js 1`] = `
"let x = Red
let y = Colors.Blue
let z = Rgb ()
let v = Vertex (1., 2., 3., 4.)
let colour = Shades.Colors.White
let u = ()
"
`;

exports[`extension.js 1`] = `
";;[%expr ]
;;[%expr.extension ]
;;[%expr.extension.with.args \\"argument\\"]
;;[%expr.extension.with.args fun x -> f x]
let x = ([%bs.raw \\"1\\"]) + ([%bs.raw \\"2\\"])
"
`;

exports[`for.js 1`] = `
";;for p = 0 to 10 do () done
;;for p = 10 downto 0 do () done
;;for p = a to b do () done
;;for p = a to b do let a = 1 in let b = 2 in a + b done
"
`;

exports[`forV2.js 1`] = `
";;let i = ref 0 in while i < 10 do Js.log i; i := ((!i) + 1) done
"
`;

exports[`ident.js 1`] = `
"let x = foo
let y = Foo.Bar.x
let x = _identWithUnderscore
let x = _ident_ident
let x = _ident_ident_
let x = __ident__
"
`;

exports[`if.js 1`] = `
";;if foo then true else false
;;if foo == 2 then let bar = 1 in let foo = 2 in bar + foo
let ifThenElse = if foo then lala else doStuff x y z
"
`;

exports[`list.js 1`] = `
"let x = []
let x = [1; 2; 3]
let x = [1; 2; 3]
let x = [(1 : int); (2 : int); (3 : int)]
let x = 4 :: 5 :: y
let x = 1 :: 2 :: (y : int list)
"
`;

exports[`parenthesized.js 1`] = `
"let x = 1
let f = 1.3
let truth = true
let truth = false
let constructor = None
let longidentConstructor = Option.None
let txt = \\"a string\\"
let otherTxt = \\"foo bar \\" ^ txt
let ident = myIdent
let aList = [1; 2]
let anArray = [|1;2|]
let aTuple = (1, 2)
let aRecord = { name = \\"steve\\"; age = 30 }
let blockExpression = let a = 1 in let b = 2 in a + b
let assertSmthing = assert true
let lazyThing = lazy true
let jsx = div ~className:\\"cx\\" ~childen:[foo] ()
let ifExpr = if true then Js.log true else Js.log false
let forExpr = for p = 0 to 10 do () done
let whileExpr = while true do doSomeImperativeThing () done
let switchExpr = match myVar with | Blue -> \\"blue\\" | Red -> \\"red\\"
let constrainedExpr = (x : int)
"
`;

exports[`primary.js 1`] = `
"let x = a.b
let x = (a.b).c
let x = H20.Water.water.h
let x = p.Parser.token
let x = (p.Lang.Parser.token).pos
;;lexbuf.lnum <- (lexbuf.lnum + 1)
let x = arr.(0)
let x = arr.((x : int))
;;arr.(0) <- (a + b)
;;f ()
;;f a
;;f a
;;f (x : int)
;;f a b c
;;f a b c
;;f ~a ~b:bArg ?c ?d:expr
;;f ~a:(x : int) ?b:(y : int)
"
`;

exports[`record.js 1`] = `
"let r = { a = expr }
let r = { a = expr }
let r = { Parsetree.pexp_attributes = [||]; Parsetree.loc = loc }
let r = { a; b; c }
let r = { Parsetree.pexp_attributes; Parsetree.loc }
let r = { Parsetree.pexp_attributes; Parsetree.loc }
let r = { a = (expr : int); b = (x : string) }
let r = { expr with pexp_attributes = [||] }
let r = { expr with pexp_attributes = [||]; pexp_loc = loc }
let r = { expr with pexp_attributes = [||] }
let r = { (make () : myRecord) with foo = bar }
let r = { (make () : myRecord) with foo = bar }
"
`;

exports[`switch.js 1`] = `
";;match x with | A -> () | B -> ()
;;match a + b with | _ -> ()
;;match a + b with | _ -> ()
"
`;

exports[`tuple.js 1`] = `
"let x = (1, 2, 3)
let x = (1, 2, 3)
let x = ((1 : int), (2 : int), (3 : int))
"
`;

exports[`unary.js 1`] = `
"let x = not true
let m = (-1)
let m = (-2.5)
let x = 5
let x = 5.4
let x = !box
let sum = (- a) - (- b)
"
`;

exports[`while.js 1`] = `
";;while not eofReached do
    let a = 1 in let b = 2 in Lexbuf.next (); (a + b) |. Js.log done
;;while (not (isLineEnding buf)) && true do foo (); next () done
"
`;
