// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`array.js 1`] = `
"let x = [|1;2;3|]
let x = [|1;2;3|]
let x = [|(1 : int);(2 : int);(3 : int)|]
"
`;

exports[`constants.js 1`] = `
"let x = true
let y = false
let txt = \\"a string\\"
let number = 1
let template = \\"amazing\\\\n  multine\\\\n  template\\\\n     string\\\\n\\"
let complexNumber = 1.6
"
`;

exports[`constructor.js 1`] = `
"let x = Red
let y = Colors.Blue
let z = Rgb ()
let v = Vertex (1., 2., 3., 4.)
let colour = Shades.Colors.White
let u = ()
"
`;

exports[`for.js 1`] = `
";;for p = 0 to 10 do () done
;;for p = 10 downto 0 do () done
;;for p = a to b do () done
;;for p = a to b do let a = 1 in let b = 2 in a + b done
"
`;

exports[`ident.js 1`] = `
"let x = foo
let y = Foo.Bar.x
let x = _identWithUnderscore
let x = _ident_ident
let x = _ident_ident_
let x = __ident__
"
`;

exports[`if.js 1`] = `
";;if foo then true else false
;;if foo == 2 then let bar = 1 in let foo = 2 in bar + foo
let ifThenElse = if foo then lala else doStuff x y z
"
`;

exports[`list.js 1`] = `
"let x = [1; 2; 3]
let x = [1; 2; 3]
let x = [(1 : int); (2 : int); (3 : int)]
let x = 4 :: 5 :: y
let x = 1 :: 2 :: (y : int list)
"
`;

exports[`parenthesized.js 1`] = `
"let x = 1
let f = 1.3
let truth = true
let truth = false
let constructor = None
let longidentConstructor = Option.None
let txt = \\"a string\\"
let otherTxt = \\"foo bar \\" ^ txt
let ident = myIdent
let aList = [1; 2]
let anArray = [|1;2|]
let aTuple = (1, 2)
let aRecord = { name = \\"steve\\"; age = 30 }
let blockExpression = let a = 1 in let b = 2 in a + b
let assertSmthing = assert true
let lazyThing = lazy true
let jsx = div ~className:\\"cx\\" ~childen:[foo] ()
let ifExpr = if true then Js.log true else Js.log false
let forExpr = for p = 0 to 10 do () done
let whileExpr = while true do doSomeImperativeThing () done
let switchExpr = match myVar with | Blue -> \\"blue\\" | Red -> \\"red\\"
let constrainedExpr = (x : int)
"
`;

exports[`primary.js 1`] = `
"let x = a.b
let x = (a.b).c
let x = H20.Water.water.h
let x = p.Parser.token
let x = (p.Lang.Parser.token).pos
;;lexbuf.lnum <- (lexbuf.lnum + 1)
let x = arr.(0)
let x = arr.((x : int))
;;arr.(0) <- (a + b)
;;f ()
;;f (x : int)
;;f a b c
;;f a b c
;;f ~a ~b:bArg ?c ?d:expr
;;f ~a:(x : int) ?b:(y : int)
"
`;

exports[`switch.js 1`] = `
";;match x with | A -> () | B -> ()
;;match a + b with | _ -> ()
;;match a + b with | _ -> ()
"
`;

exports[`tuple.js 1`] = `
"let x = (1, 2, 3)
let x = (1, 2, 3)
let x = ((1 : int), (2 : int), (3 : int))
"
`;

exports[`unary.js 1`] = `
"let x = not true
let m = (-1)
let m = (-2.5)
let x = 5
let x = 5.4
let x = !box
let sum = (- a) - (- b)
"
`;

exports[`while.js 1`] = `
";;while not eofReached do
    let a = 1 in let b = 2 in Lexbuf.next (); (a + b) |. Js.log done
;;while (not (isLineEnding buf)) && true do foo (); next () done
"
`;
