// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`equalAfterBinaryExpr.js 1`] = `
"=====Parsetree==========================================
let rec _addLoop rbt currentNode =
  if (Some currentNode) == (rbt |. root)
  then currentNode.color <- Black
  else
    if (currentNode.parent |. castNotOption).color == Black
    then ()
    else
      if
        (let uncle = uncleOf currentNode in
         (uncle != None) && ((uncle |. castNotOption).color == Red))
      then
        ((currentNode.parent |. castNotOption).color <- Black;
         ((uncleOf currentNode) |. castNotOption).color <- Black;
         ((grandParentOf currentNode) |. castNotOption).color <- Red;
         _addLoop rbt ((grandParentOf currentNode) |. castNotOption))
      else
        (let currentNode =
           if
             (not (isLeft currentNode)) &&
               (isLeft (currentNode.parent |. castNotOption))
           then
             (rotateLeft rbt (currentNode.parent |. castNotOption);
              currentNode.left |. castNotOption)
           else
             if
               (isLeft currentNode) &&
                 (not (isLeft (currentNode.parent |. castNotOption)))
             then
               (rotateRight rbt (currentNode.parent |. castNotOption);
                currentNode.right |. castNotOption)
             else currentNode in
         (currentNode.parent |. castNotOption).color <- Black;
         ((grandParentOf currentNode) |. castNotOption).color <- Red;
         if isLeft currentNode
         then rotateRight rbt ((grandParentOf currentNode) |. castNotOption)
         else rotateLeft rbt ((grandParentOf currentNode) |. castNotOption))
let removeNode rbt node =
  if nodeToRemove.color == Black
  then
    (if successor.color == Red
     then
       (successor.color <- Black;
        if successor.parent == None then rbt |. (rootSet (Some successor)))
     else
       (let break = ref false in
        let successorRef = ref successor in
        while not break.contents do
          let successor = successorRef.contents in
          match successor.parent with
          | None ->
              (rbt |. (rootSet (Some successor)); break.contents <- true)
          | Some successorParent ->
              let sibling = siblingOf successor in
              (if
                 (sibling != None) &&
                   ((sibling |. castNotOption).color == Red)
               then
                 (successorParent.color <- Red;
                  (sibling |. castNotOption).color <- Black;
                  if isLeft successor
                  then rotateLeft rbt successorParent
                  else rotateRight rbt successorParent);
               (let sibling = siblingOf successor in
                let siblingNN = sibling |. castNotOption in
                if
                  (successorParent.color == Black) &&
                    ((sibling == None) ||
                       (((siblingNN.color == Black) &&
                           ((siblingNN.left == None) ||
                              ((siblingNN.left |. castNotOption).color ==
                                 Black)))
                          &&
                          ((siblingNN.right == None) ||
                             ((siblingNN.right |. castNotOption).color ==
                                Black))))
                then
                  (if sibling != None then siblingNN.color <- Red;
                   successorRef.contents <- successorParent)
                else
                  if
                    (successorParent.color == Red) &&
                      ((sibling == None) ||
                         (((siblingNN.color == Black) &&
                             ((siblingNN.left == None) ||
                                ((siblingNN.left |. castNotOption).color ==
                                   Black)))
                            &&
                            ((siblingNN.right == None) ||
                               ((siblingNN.right |. castNotOption).color ==
                                  Black))))
                  then
                    (if sibling != None then siblingNN.color <- Red;
                     successorParent.color <- Black;
                     break.contents <- true)
                  else
                    if
                      (sibling != None) &&
                        ((sibling |. castNotOption).color == Black)
                    then
                      (let sibling = sibling |. castNotOption in
                       if
                         (((isLeft successor) &&
                             ((sibling.right == None) ||
                                ((sibling.right |. castNotOption).color ==
                                   Black)))
                            && (sibling.left != None))
                           && ((sibling.left |. castNotOption).color == Red)
                       then
                         (sibling.color <- Red;
                          (sibling.left |. castNotOption).color <- Black;
                          rotateRight rbt sibling)
                       else
                         if
                           (((not (isLeft successor)) &&
                               ((sibling.left == None) ||
                                  ((sibling.left |. castNotOption).color ==
                                     Black)))
                              && (sibling.right != None))
                             &&
                             ((sibling.right |. castNotOption).color == Red)
                         then
                           (sibling.color <- Red;
                            (sibling.right |. castNotOption).color <- Black;
                            rotateLeft rbt sibling);
                       break.contents <- true)
                    else
                      (let sibling = siblingOf successor in
                       let sibling = sibling |. castNotOption in
                       sibling.color <- (successorParent.color);
                       if isLeft successor
                       then
                         ((sibling.right |. castNotOption).color <- Black;
                          rotateRight rbt successorParent)
                       else
                         ((sibling.left |. castNotOption).color <- Black;
                          rotateLeft rbt successorParent))))
          done));
  if ((isLeaf successor)[@bs ])
  then (if (rbt |. root) == (Some successor) then (rbt |. root) = None)
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/equalAfterBinaryExpr.js\\", line 169, characters 16-17:


167 â”‚    if isLeaf(. successor) {
168 â”‚      if rbt->root === Some(successor) {
[31m169[0m â”‚        rbt->root [31m=[0m None
170 â”‚      }
171 â”‚    }

Did you mean \`==\` here?



========================================================"
`;

exports[`jsxChildren.js 1`] = `
"=====Parsetree==========================================
type nonrec action =
  | AddUser 
;;((string ~children:[] ())[@JSX ])
let (a : action) = AddUser \\"test\\"
;;etype
;;s = { x = [((i ~children:[] ())[@JSX ])] }
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 1, characters 21-29:


[31m1[0m â”‚  type action = AddUser[31m<string>[0m
2 â”‚  
3 â”‚  let a: action = AddUser(\\"test\\")

Missing </string>


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-18:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                       [31m^[0m

Did you forget a \`[\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^^[0m

Did you forget a \`</\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-20:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list[31m<i>[0m}

Closing jsx name should be the same as the opening name. Did you mean </i> ?


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`]\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 8-9:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s [31m=[0m {x:list<i>}

Did you mean \`==\` here?



========================================================"
`;

exports[`nonRecTypes.js 1`] = `
"=====Parsetree==========================================
include
  struct
    include
      struct
        type nonrec 'value t =
          {
          mutable size: int ;
          mutable root: 'value node option ;
          compare: Js.Internal.fn }
        ;;[|{j|Arity_2('value, 'value)], int),
                      };
                    }: {

                    }
                  );
          type t('value);
          external t:
            (
              ~size: int,
              ~root: option(node('value)),
              ~compare: Js.Internal.fn([ | |j};(
            Arity_2 (value, value))|]
        ;;int
        ;;(t value) = \\"\\"
        ;;\\"BS:6.0.1132149166190000000000#000000000\\\\r000000000&000000000#145160160A160$size@160160A160$root@160160A160'compare@@\\"
        external sizeSet :
          'value t -> int -> unit = \\"size\\"
            \\"BS:6.0.1132149166190000000000021000000000\\\\t000000000026000000000025176160160A145@160160A004003@E151160$size@\\"
        ;;[|((\\"use sizeGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external size :
          'value t -> int = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$size@\\"
        ;;[|((1)[@internal.arity ])|]
        external sizeGet :
          'value t -> int = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$size@\\"
        external rootSet :
          'value t -> 'value node option -> unit = \\"root\\"
            \\"BS:6.0.1132149166190000000000021000000000\\\\t000000000026000000000025176160160A145@160160A004003@E151160$root@\\"
        ;;[|((\\"use rootGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external root :
          'value t -> 'value node option = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$root@\\"
        ;;[|((1)[@internal.arity ])|]
        external rootGet :
          'value t -> 'value node option = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$root@\\"
        ;;[|((\\"use compareGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external compare : 'value t -> Js.Internal.fn
        ;;[|{j|Arity_2('value, 'value)], int) =
            \\"\\"
            \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";
          [@internal.arity 1]
          external compareGet:
            t('value) => Js.Internal.fn([ | |j};(
            Arity_2 (value, value))|]
        ;;int
        ;;\\"\\"
        ;;\\"BS:6.0.1132149166190000000000019000000000007000000000020000000000019176160160A145@@A152160'compare@\\"
      end
    let has rbt value = (_findNode rbt (rootGet rbt) value) != None
    let rec minNode node = [%napkinscript.exprhole ]
    let findMin rbt = [%napkinscript.exprhole ]
    let removeNode rbt node =
      let nodeToRemove =
        match ((leftGet node), (rightGet node)) with
        | (Some _, Some _) ->
            let successor = castNotOption (minNode (rightGet node)) in
            (valueSet node (valueGet successor);
             heightSet node (heightGet successor);
             successor)
        | _ -> node in
      let successor =
        match leftGet nodeToRemove with
        | None -> rightGet nodeToRemove
        | left -> left in
      let (successor, isLeaf) =
        match successor with
        | None ->
            let leaf =
              createNode ~value:(Js.Internal.raw_expr \\"0\\") ~color:Black
                ~height:0. in
            let isLeaf = Js.Internal.fn_mk1 (fun x -> x == leaf) in
            (leaf, isLeaf)
        | Some successor ->
            (successor, (Js.Internal.fn_mk1 (fun _ -> false))) in
      let nodeParent = parentGet nodeToRemove in
      parentSet successor nodeParent;
      (match nodeParent with
       | None -> ()
       | Some parent ->
           leftOrRightSet parent ~node:nodeToRemove (Some successor));
      updateSumRecursive rbt successor;
      if (colorGet nodeToRemove) == Black
      then
        (if (colorGet successor) == Red
         then
           (colorSet successor Black;
            if (parentGet successor) == None
            then rootSet rbt (Some successor))
         else
           (let break = ref false in
            let successorRef = ref successor in
            while not break.contents do
              let successor = successorRef.contents in
              match parentGet successor with
              | None ->
                  (rootSet rbt (Some successor); break.contents <- true)
              | Some successorParent ->
                  let sibling = siblingOf successor in
                  (if
                     (sibling != None) &&
                       ((colorGet (castNotOption sibling)) == Red)
                   then
                     (colorSet successorParent Red;
                      colorSet (castNotOption sibling) Black;
                      if isLeft successor
                      then rotateLeft rbt successorParent
                      else rotateRight rbt successorParent);
                   (let sibling = siblingOf successor in
                    let siblingNN = castNotOption sibling in
                    if
                      ((colorGet successorParent) == Black) &&
                        ((sibling == None) ||
                           ((((colorGet siblingNN) == Black) &&
                               (((leftGet siblingNN) == None) ||
                                  ((colorGet
                                      (castNotOption (leftGet siblingNN)))
                                     == Black)))
                              &&
                              (((rightGet siblingNN) == None) ||
                                 ((colorGet
                                     (castNotOption (rightGet siblingNN)))
                                    == Black))))
                    then
                      (if sibling != None then colorSet siblingNN Red;
                       successorRef.contents <- successorParent)
                    else
                      if
                        ((colorGet successorParent) == Red) &&
                          ((sibling == None) ||
                             ((((colorGet siblingNN) == Black) &&
                                 (((leftGet siblingNN) == None) ||
                                    ((colorGet
                                        (castNotOption (leftGet siblingNN)))
                                       == Black)))
                                &&
                                (((rightGet siblingNN) == None) ||
                                   ((colorGet
                                       (castNotOption (rightGet siblingNN)))
                                      == Black))))
                      then
                        (if sibling != None then colorSet siblingNN Red;
                         colorSet successorParent Black;
                         break.contents <- true)
                      else
                        if
                          (sibling != None) &&
                            ((colorGet (castNotOption sibling)) == Black)
                        then
                          (let sibling = castNotOption sibling in
                           if
                             (((isLeft successor) &&
                                 (((rightGet sibling) == None) ||
                                    ((colorGet
                                        (castNotOption (rightGet sibling)))
                                       == Black)))
                                && ((leftGet sibling) != None))
                               &&
                               ((colorGet (castNotOption (leftGet sibling)))
                                  == Red)
                           then
                             (colorSet sibling Red;
                              colorSet (castNotOption (leftGet sibling))
                                Black;
                              rotateRight rbt sibling)
                           else
                             if
                               (((not (isLeft successor)) &&
                                   (((leftGet sibling) == None) ||
                                      ((colorGet
                                          (castNotOption (leftGet sibling)))
                                         == Black)))
                                  && ((rightGet sibling) != None))
                                 &&
                                 ((colorGet
                                     (castNotOption (rightGet sibling)))
                                    == Red)
                             then
                               (colorSet sibling Red;
                                colorSet (castNotOption (rightGet sibling))
                                  Black;
                                rotateLeft rbt sibling);
                           break.contents <- true)
                        else
                          (let sibling = siblingOf successor in
                           let sibling = castNotOption sibling in
                           colorSet sibling (colorGet successorParent);
                           if isLeft successor
                           then
                             (colorSet (castNotOption (rightGet sibling))
                                Black;
                              rotateRight rbt successorParent)
                           else
                             (colorSet (castNotOption (leftGet sibling))
                                Black;
                              rotateLeft rbt successorParent))))
              done));
      if Js.Internal.fn_run1 isLeaf successor
      then
        (if (rootGet rbt) == (Some successor) then rootSet rbt None;
         (match parentGet successor with
          | None -> ()
          | Some parent -> leftOrRightSet parent ~node:successor None))
    let remove rbt value =
      match _findNode rbt (rootGet rbt) value with
      | Some node ->
          (removeNode rbt node;
           sizeSet rbt ((sizeGet rbt) - 1);
           Some (heightGet node))
      | None -> None
    let findThroughCallback rbt cb =
      let rec findThroughCallback rbt node cb =
        match node with
        | None -> None
        | Some node ->
            let cmp = Js.Internal.fn_run1 cb (valueGet node) in
            if cmp == 0
            then Some node
            else
              if cmp < 0
              then findThroughCallback rbt (leftGet node) cb
              else findThroughCallback rbt (rightGet node) cb in
      match findThroughCallback rbt (rootGet rbt) cb with
      | None -> None
      | Some node -> Some (valueGet node)
    let make ~compare  = t ~size:0 ~root:None ~compare
    let rec heightOfInterval rbt node lhs rhs =
      match node with
      | None -> 0.
      | Some n ->
          if (lhs == None) && (rhs == None)
          then sumGet n
          else
            if
              (lhs != None) &&
                ((Js.Internal.fn_run2 (compareGet rbt) (valueGet n)
                    (castNotOption lhs))
                   < 0)
            then heightOfInterval rbt (rightGet n) lhs rhs
            else
              if
                (rhs != None) &&
                  ((Js.Internal.fn_run2 (compareGet rbt) (valueGet n)
                      (castNotOption rhs))
                     > 0)
              then heightOfInterval rbt (leftGet n) lhs rhs
              else
                ((heightGet n) +. (heightOfInterval rbt (leftGet n) lhs None))
                  +. (heightOfInterval rbt (rightGet n) None rhs)
    let heightOfInterval rbt lhs rhs =
      heightOfInterval rbt (rootGet rbt) lhs rhs
    let rec firstVisibleNode node offset =
      match node with
      | None -> None
      | Some node ->
          if (sumGet node) <= offset
          then None
          else
            (let nodeHeight = heightGet node in
             let sumLeft =
               match leftGet node with
               | None -> 0.0
               | Some left -> sumGet left in
             if sumLeft > offset
             then firstVisibleNode (leftGet node) offset
             else
               if (sumLeft +. nodeHeight) > offset
               then Some node
               else
                 firstVisibleNode (rightGet node)
                   (offset -. (sumLeft +. nodeHeight)))
    let lastVisibleNode node offset =
      match firstVisibleNode node offset with
      | None -> maxNode node
      | first -> first
    let firstVisible rbt ~offset  =
      match firstVisibleNode (rootGet rbt) offset with
      | None -> None
      | Some node -> Some (valueGet node)
    let rec leftmost node =
      match leftGet node with | None -> node | Some node -> leftmost node
    let rec firstRightParent node =
      match parentGet node with
      | None -> None
      | Some parent ->
          if isLeft node then Some parent else firstRightParent parent
    let nextNode node =
      match rightGet node with
      | None -> firstRightParent node
      | Some right -> Some (leftmost right)
    let rec sumLeftSpine node ~fromRightChild  =
      let leftSpine =
        match leftGet node with
        | None -> heightGet node
        | Some left ->
            if fromRightChild then (heightGet node) +. (sumGet left) else 0.0 in
      match parentGet node with
      | None -> leftSpine
      | Some parent ->
          leftSpine +.
            (sumLeftSpine parent
               ~fromRightChild:((rightGet parent) == (Some node)))
    let getY node =
      (sumLeftSpine node ~fromRightChild:true) -. (heightGet node)
    let linearSearch rbt callback =
      let rec find node callback =
        if Js.Internal.fn_run1 callback (valueGet node)
        then Some (valueGet node)
        else
          (match nextNode node with
           | None -> None
           | Some node -> find node callback) in
      match minNode (rootGet rbt) with
      | None -> None
      | Some node -> find node callback
    let rec iterate ~inclusive  firstNode lastNode ~callback  =
      match firstNode with
      | None -> ()
      | Some node ->
          (if inclusive then Js.Internal.fn_run1 callback node;
           if firstNode != lastNode
           then
             (if not inclusive then Js.Internal.fn_run1 callback node;
              iterate ~inclusive (nextNode node) lastNode ~callback))
    let rec iterateWithY ?y  ~inclusive  firstNode lastNode ~callback  =
      match firstNode with
      | None -> ()
      | Some node ->
          let y = match y with | None -> getY node | Some y -> y in
          (if inclusive then Js.Internal.fn_run2 callback node y;
           if firstNode != lastNode
           then
             (if not inclusive then Js.Internal.fn_run2 callback node y;
              iterateWithY ~y:(y +. (heightGet node)) ~inclusive
                (nextNode node) lastNode ~callback))
    let rec updateSum node ~delta  =
      match node with
      | None -> ()
      | Some node ->
          (sumSet node ((sumGet node) +. delta);
           updateSum (parentGet node) ~delta)
    let setHeight rbt value ~height  =
      match _findNode rbt (rootGet rbt) value with
      | None -> ()
      | Some node ->
          let delta = height -. (heightGet node) in
          (heightSet node height; updateSum (Some node) ~delta)
    type nonrec 'value oldNewVisibleNodes =
      {
      mutable old: 'value array ;
      mutable new_: 'value array }
  end
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 4, characters 28-29:


2 â”‚            include (
3 â”‚                      {
[31m4[0m â”‚                        type t[31m([0m'value) = {
5 â”‚                          mutable size: int,
6 â”‚                          mutable root: option(node('value)),

Type params require diamonds, example: type node<'a>


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 6, characters 44-45:


4 â”‚                        type t('value) = {
5 â”‚                          mutable size: int,
[31m6[0m â”‚                          mutable root: option[31m([0mnode('value)),
7 â”‚                          compare:
8 â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 6, characters 49-50:


4 â”‚                        type t('value) = {
5 â”‚                          mutable size: int,
[31m6[0m â”‚                          mutable root: option(node[31m([0m'value)),
7 â”‚                          compare:
8 â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 40-41:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn[31m([0m[ | \`Arity_2('value, 'value)], int),
9 â”‚                        };
10 â”‚                      }: {

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 41-42:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),          
                                               [31m^[0m
9 â”‚                        };
10 â”‚                      }: {

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 41-42:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),          
                                               [31m^[0m
9 â”‚                        };
10 â”‚                      }: {

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 43-44:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ [31m|[0m \`Arity_2('value, 'value)], int),
9 â”‚                        };
10 â”‚                      }: {

I'm not sure what to parse here when looking at \\"|\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 52-53:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2([31m'[0mvalue, 'value)], int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 60-61:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, [31m'[0mvalue)], int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 68-69:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)][31m,[0m int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 73-74:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int[31m)[0m
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 20, characters 12-13:


18 â”‚                ~root: option(node('value)),
19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
[31m20[0m â”‚              [31m)[0m =>
21 â”‚              t('value) =
22 â”‚              \\"\\"

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 20, characters 14-16:


18 â”‚                ~root: option(node('value)),
19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
[31m20[0m â”‚              ) [31m=>[0m
21 â”‚              t('value) =
22 â”‚              \\"\\"

I'm not sure what to parse here when looking at \\"=>\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 21, characters 14-15:


19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
20 â”‚              ) =>
[31m21[0m â”‚              t([31m'[0mvalue) =
22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 21, characters 22-23:


19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
20 â”‚              ) =>
[31m21[0m â”‚              t('value) [31m=[0m
22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";

Did you mean \`==\` here?


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 24, characters 30-31:


22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";
[31m24[0m â”‚            external sizeSet: (t[31m([0m'value), int) => unit =
25 â”‚              \\"size\\"
26 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$size@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 31, characters 26-27:


29 â”‚            ]
30 â”‚            [@internal.arity 1]
[31m31[0m â”‚            external size: t[31m([0m'value) => int =
32 â”‚              \\"\\"
33 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 35, characters 29-30:


33 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
34 â”‚            [@internal.arity 1]
[31m35[0m â”‚            external sizeGet: t[31m([0m'value) => int =
36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 30-31:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t[31m([0m'value), option(node('value))) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 46-47:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t('value), option[31m([0mnode('value))) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 51-52:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t('value), option(node[31m([0m'value))) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 26-27:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t[31m([0m'value) => option(node('value)) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 44-45:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t('value) => option[31m([0mnode('value)) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 49-50:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t('value) => option(node[31m([0m'value)) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 29-30:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t[31m([0m'value) => option(node('value)) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 47-48:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t('value) => option[31m([0mnode('value)) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 52-53:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t('value) => option(node[31m([0m'value)) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 13-14:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t[31m([0m'value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 39-40:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn[31m([0m[ | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =          
                                              [31m^[0m
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =          
                                              [31m^[0m
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Did you forget a \`=\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([31m[[0m | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

An external definition should have at least one primitive. Example: \\"setTimeout\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 42-43:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ [31m|[0m \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"|\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 53-54:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2([31m'[0mvalue, 'value)], int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 61-62:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, [31m'[0mvalue)], int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 69-70:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)][31m,[0m int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 74-75:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int[31m)[0m =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 76-77:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) [31m=[0m
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"=\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 65, characters 9-10:


63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";
[31m65[0m â”‚          };          
               [31m^[0m
66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
67 â”‚  let rec minNode = node =>

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 67, characters 25-29:


65 â”‚          };
66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
[31m67[0m â”‚  let rec minNode = node =>
68 â”‚  let findMin = rbt =>
69 â”‚  let removeNode = (rbt, node) => {

I'm not sure what to parse here when looking at \\"let\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 68, characters 20-24:


66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
67 â”‚  let rec minNode = node =>
[31m68[0m â”‚  let findMin = rbt =>
69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =

I'm not sure what to parse here when looking at \\"let\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 434, characters 30-31:


432 â”‚      updateSum(Some(node), ~delta);
433 â”‚    };
[31m434[0m â”‚  type nonrec oldNewVisibleNodes[31m([0m'value) = {
435 â”‚    mutable old: array('value),
436 â”‚    mutable new_: array('value),

Type params require diamonds, example: type node<'a>


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 435, characters 20-21:


433 â”‚    };
434 â”‚  type nonrec oldNewVisibleNodes('value) = {
[31m435[0m â”‚    mutable old: array[31m([0m'value),
436 â”‚    mutable new_: array('value),
437 â”‚  };

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 436, characters 21-22:


434 â”‚  type nonrec oldNewVisibleNodes('value) = {
435 â”‚    mutable old: array('value),
[31m436[0m â”‚    mutable new_: array[31m([0m'value),
437 â”‚  };

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 437, characters 2-3:


435 â”‚    mutable old: array('value),
436 â”‚    mutable new_: array('value),
[31m437[0m â”‚  };          
        [31m^[0m

Did you forget a \`}\` here? 



========================================================"
`;
