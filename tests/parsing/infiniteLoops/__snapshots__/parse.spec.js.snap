// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`equalAfterBinaryExpr.js 1`] = `
"=====Parsetree==========================================
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
let rec _addLoop rbt currentNode =
  ((match (Some currentNode) == (rbt |. root) with
    | true -> currentNode.color <- Black
    | _ when (currentNode.parent |. castNotOption).color == Black -> ()
    | _ when
        ((let uncle = uncleOf currentNode in
          (uncle != None) && ((uncle |. castNotOption).color == Red))
        [@ns.braces ]) ->
        ((currentNode.parent |. castNotOption).color <- Black;
         ((uncleOf currentNode) |. castNotOption).color <- Black;
         ((grandParentOf currentNode) |. castNotOption).color <- Red;
         _addLoop rbt ((grandParentOf currentNode) |. castNotOption))
    | _ ->
        let currentNode =
          match (not (isLeft currentNode)) &&
                  (isLeft (currentNode.parent |. castNotOption))
          with
          | true ->
              (rotateLeft rbt (currentNode.parent |. castNotOption);
               currentNode.left |. castNotOption)
          | _ when
              (isLeft currentNode) &&
                (not (isLeft (currentNode.parent |. castNotOption)))
              ->
              (rotateRight rbt (currentNode.parent |. castNotOption);
               currentNode.right |. castNotOption)
          | _ -> currentNode in
        ((currentNode.parent |. castNotOption).color <- Black;
         ((grandParentOf currentNode) |. castNotOption).color <- Red;
         (match isLeft currentNode with
          | true ->
              rotateRight rbt ((grandParentOf currentNode) |. castNotOption)
          | _ ->
              rotateLeft rbt ((grandParentOf currentNode) |. castNotOption))))
  [@ns.braces ])
let removeNode rbt node =
  (((match nodeToRemove.color == Black with
     | true ->
         (match successor.color == Red with
          | true ->
              (successor.color <- Black;
               (match successor.parent == None with
                | true -> rbt |. (rootSet (Some successor))
                | _ -> ()))
          | _ ->
              let break = ref false in
              let successorRef = ref successor in
              while not break.contents do
                let successor = successorRef.contents in
                (match successor.parent with
                 | None ->
                     (rbt |. (rootSet (Some successor));
                      break.contents <- true)
                 | Some successorParent ->
                     let sibling = siblingOf successor in
                     ((match (sibling != None) &&
                               ((sibling |. castNotOption).color == Red)
                       with
                       | true ->
                           (successorParent.color <- Red;
                            (sibling |. castNotOption).color <- Black;
                            (match isLeft successor with
                             | true -> rotateLeft rbt successorParent
                             | _ -> rotateRight rbt successorParent))
                       | _ -> ());
                      (let sibling = siblingOf successor in
                       let siblingNN = sibling |. castNotOption in
                       match (successorParent.color == Black) &&
                               ((sibling == None) ||
                                  (((siblingNN.color == Black) &&
                                      ((siblingNN.left == None) ||
                                         ((siblingNN.left |. castNotOption).color
                                            == Black)))
                                     &&
                                     ((siblingNN.right == None) ||
                                        ((siblingNN.right |. castNotOption).color
                                           == Black))))
                       with
                       | true ->
                           ((match sibling != None with
                             | true -> siblingNN.color <- Red
                             | _ -> ());
                            successorRef.contents <- successorParent)
                       | _ when
                           (successorParent.color == Red) &&
                             ((sibling == None) ||
                                (((siblingNN.color == Black) &&
                                    ((siblingNN.left == None) ||
                                       ((siblingNN.left |. castNotOption).color
                                          == Black)))
                                   &&
                                   ((siblingNN.right == None) ||
                                      ((siblingNN.right |. castNotOption).color
                                         == Black))))
                           ->
                           ((match sibling != None with
                             | true -> siblingNN.color <- Red
                             | _ -> ());
                            successorParent.color <- Black;
                            break.contents <- true)
                       | _ when
                           (sibling != None) &&
                             ((sibling |. castNotOption).color == Black)
                           ->
                           let sibling = sibling |. castNotOption in
                           ((match (((isLeft successor) &&
                                       ((sibling.right == None) ||
                                          ((sibling.right |. castNotOption).color
                                             == Black)))
                                      && (sibling.left != None))
                                     &&
                                     ((sibling.left |. castNotOption).color
                                        == Red)
                             with
                             | true ->
                                 (sibling.color <- Red;
                                  (sibling.left |. castNotOption).color <-
                                    Black;
                                  rotateRight rbt sibling)
                             | _ when
                                 (((not (isLeft successor)) &&
                                     ((sibling.left == None) ||
                                        ((sibling.left |. castNotOption).color
                                           == Black)))
                                    && (sibling.right != None))
                                   &&
                                   ((sibling.right |. castNotOption).color ==
                                      Red)
                                 ->
                                 (sibling.color <- Red;
                                  (sibling.right |. castNotOption).color <-
                                    Black;
                                  rotateLeft rbt sibling)
                             | _ -> ());
                            break.contents <- true)
                       | _ ->
                           let sibling = siblingOf successor in
                           let sibling = sibling |. castNotOption in
                           (sibling.color <- (successorParent.color);
                            (match isLeft successor with
                             | true ->
                                 ((sibling.right |. castNotOption).color <-
                                    Black;
                                  rotateRight rbt successorParent)
                             | _ ->
                                 ((sibling.left |. castNotOption).color <-
                                    Black;
                                  rotateLeft rbt successorParent))))))
                done)
     | _ -> ());
    (match ((isLeaf successor)[@bs ]) with
     | true ->
         (match (rbt |. root) == (Some successor) with
          | true -> (rbt |. root) = None
          | _ -> ())
     | _ -> ()))
  [@ns.braces ])
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/equalAfterBinaryExpr.js\\", line 169, characters 16-17:


167 â”‚    if isLeaf(. successor) {
168 â”‚      if rbt->root === Some(successor) {
[31m169[0m â”‚        rbt->root [31m=[0m None
170 â”‚      }
171 â”‚    }

Did you mean \`==\` here?



========================================================"
`;

exports[`jsxChildren.js 1`] = `
"=====Parsetree==========================================
type nonrec action =
  | AddUser 
;;((string ~children:[] ())[@JSX ])
let (a : action) = AddUser \\"test\\"
;;etype
;;s = { x = [((i ~children:[] ())[@JSX ])] }
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 1, characters 21-29:


[31m1[0m â”‚  type action = AddUser[31m<string>[0m
2 â”‚  
3 â”‚  let a: action = AddUser(\\"test\\")

Missing </string>


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-18:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                       [31m^[0m

Did you forget a \`[\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^^[0m

Did you forget a \`</\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-20:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list[31m<i>[0m}

Closing jsx name should be the same as the opening name. Did you mean </i> ?


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`,\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>[31m}[0m

I'm not sure what to parse here when looking at \\"}\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 21-22:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                           [31m^[0m

Did you forget a \`]\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 21-22:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                           [31m^[0m

Did you forget a \`,\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 21-22:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                           [31m^[0m

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 8-9:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s [31m=[0m {x:list<i>}

Did you mean \`==\` here?



========================================================"
`;

exports[`nonRecTypes.js 1`] = `
"=====Parsetree==========================================
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
collect
include
  struct
    include
      struct
        type nonrec 'value t =
          {
          mutable size: int ;
          mutable root: 'value node option ;
          compare: Js.Internal.fn }
        ;;[|{j|Arity_2('value, 'value)], int),
                      };
                    }: {

                    }
                  );
          type t('value);
          external t:
            (
              ~size: int,
              ~root: option(node('value)),
              ~compare: Js.Internal.fn([ | |j};(
            Arity_2 (value, value))|]
        ;;int
        ;;(t value) = \\"\\"
        ;;\\"BS:6.0.1132149166190000000000#000000000\\\\r000000000&000000000#145160160A160$size@160160A160$root@160160A160'compare@@\\"
        external sizeSet :
          'value t -> int -> unit = \\"size\\"
            \\"BS:6.0.1132149166190000000000021000000000\\\\t000000000026000000000025176160160A145@160160A004003@E151160$size@\\"
        ;;[|((\\"use sizeGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external size :
          'value t -> int = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$size@\\"
        ;;[|((1)[@internal.arity ])|]
        external sizeGet :
          'value t -> int = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$size@\\"
        external rootSet :
          'value t -> 'value node option -> unit = \\"root\\"
            \\"BS:6.0.1132149166190000000000021000000000\\\\t000000000026000000000025176160160A145@160160A004003@E151160$root@\\"
        ;;[|((\\"use rootGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external root :
          'value t -> 'value node option = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$root@\\"
        ;;[|((1)[@internal.arity ])|]
        external rootGet :
          'value t -> 'value node option = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$root@\\"
        ;;[|((\\"use compareGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external compare : 'value t -> Js.Internal.fn
        ;;[|{j|Arity_2('value, 'value)], int) =
            \\"\\"
            \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";
          [@internal.arity 1]
          external compareGet:
            t('value) => Js.Internal.fn([ | |j};(
            Arity_2 (value, value))|]
        ;;int
        ;;\\"\\"
        ;;\\"BS:6.0.1132149166190000000000019000000000007000000000020000000000019176160160A145@@A152160'compare@\\"
      end
    let has rbt value = (_findNode rbt (rootGet rbt) value) != None
    let rec minNode node = [%napkinscript.exprhole ]
    let findMin rbt = [%napkinscript.exprhole ]
    let removeNode rbt node =
      ((let nodeToRemove =
          match ((leftGet node), (rightGet node)) with
          | (Some _, Some _) ->
              let successor = castNotOption (minNode (rightGet node)) in
              (valueSet node (valueGet successor);
               heightSet node (heightGet successor);
               successor)
          | _ -> node in
        let successor =
          match leftGet nodeToRemove with
          | None -> rightGet nodeToRemove
          | left -> left in
        let (successor, isLeaf) =
          match successor with
          | None ->
              let leaf =
                createNode ~value:(Js.Internal.raw_expr \\"0\\") ~color:Black
                  ~height:0. in
              let isLeaf = Js.Internal.fn_mk1 (fun x -> x == leaf) in
              (leaf, isLeaf)
          | Some successor ->
              (successor, (Js.Internal.fn_mk1 (fun _ -> false))) in
        let nodeParent = parentGet nodeToRemove in
        parentSet successor nodeParent;
        (match nodeParent with
         | None -> ()
         | Some parent ->
             leftOrRightSet parent ~node:nodeToRemove (Some successor));
        updateSumRecursive rbt successor;
        (match (colorGet nodeToRemove) == Black with
         | true ->
             (match (colorGet successor) == Red with
              | true ->
                  (colorSet successor Black;
                   (match (parentGet successor) == None with
                    | true -> rootSet rbt (Some successor)
                    | _ -> ()))
              | _ ->
                  let break = ref false in
                  let successorRef = ref successor in
                  while not break.contents do
                    let successor = successorRef.contents in
                    (match parentGet successor with
                     | None ->
                         (rootSet rbt (Some successor);
                          break.contents <- true)
                     | Some successorParent ->
                         let sibling = siblingOf successor in
                         ((match (sibling != None) &&
                                   ((colorGet (castNotOption sibling)) == Red)
                           with
                           | true ->
                               (colorSet successorParent Red;
                                colorSet (castNotOption sibling) Black;
                                (match isLeft successor with
                                 | true -> rotateLeft rbt successorParent
                                 | _ -> rotateRight rbt successorParent))
                           | _ -> ());
                          (let sibling = siblingOf successor in
                           let siblingNN = castNotOption sibling in
                           match ((colorGet successorParent) == Black) &&
                                   ((sibling == None) ||
                                      ((((colorGet siblingNN) == Black) &&
                                          (((leftGet siblingNN) == None) ||
                                             ((colorGet
                                                 (castNotOption
                                                    (leftGet siblingNN)))
                                                == Black)))
                                         &&
                                         (((rightGet siblingNN) == None) ||
                                            ((colorGet
                                                (castNotOption
                                                   (rightGet siblingNN)))
                                               == Black))))
                           with
                           | true ->
                               ((match sibling != None with
                                 | true -> colorSet siblingNN Red
                                 | _ -> ());
                                successorRef.contents <- successorParent)
                           | _ when
                               ((colorGet successorParent) == Red) &&
                                 ((sibling == None) ||
                                    ((((colorGet siblingNN) == Black) &&
                                        (((leftGet siblingNN) == None) ||
                                           ((colorGet
                                               (castNotOption
                                                  (leftGet siblingNN)))
                                              == Black)))
                                       &&
                                       (((rightGet siblingNN) == None) ||
                                          ((colorGet
                                              (castNotOption
                                                 (rightGet siblingNN)))
                                             == Black))))
                               ->
                               ((match sibling != None with
                                 | true -> colorSet siblingNN Red
                                 | _ -> ());
                                colorSet successorParent Black;
                                break.contents <- true)
                           | _ when
                               (sibling != None) &&
                                 ((colorGet (castNotOption sibling)) == Black)
                               ->
                               let sibling = castNotOption sibling in
                               ((match (((isLeft successor) &&
                                           (((rightGet sibling) == None) ||
                                              ((colorGet
                                                  (castNotOption
                                                     (rightGet sibling)))
                                                 == Black)))
                                          && ((leftGet sibling) != None))
                                         &&
                                         ((colorGet
                                             (castNotOption (leftGet sibling)))
                                            == Red)
                                 with
                                 | true ->
                                     (colorSet sibling Red;
                                      colorSet
                                        (castNotOption (leftGet sibling))
                                        Black;
                                      rotateRight rbt sibling)
                                 | _ when
                                     (((not (isLeft successor)) &&
                                         (((leftGet sibling) == None) ||
                                            ((colorGet
                                                (castNotOption
                                                   (leftGet sibling)))
                                               == Black)))
                                        && ((rightGet sibling) != None))
                                       &&
                                       ((colorGet
                                           (castNotOption (rightGet sibling)))
                                          == Red)
                                     ->
                                     (colorSet sibling Red;
                                      colorSet
                                        (castNotOption (rightGet sibling))
                                        Black;
                                      rotateLeft rbt sibling)
                                 | _ -> ());
                                break.contents <- true)
                           | _ ->
                               let sibling = siblingOf successor in
                               let sibling = castNotOption sibling in
                               (colorSet sibling (colorGet successorParent);
                                (match isLeft successor with
                                 | true ->
                                     (colorSet
                                        (castNotOption (rightGet sibling))
                                        Black;
                                      rotateRight rbt successorParent)
                                 | _ ->
                                     (colorSet
                                        (castNotOption (leftGet sibling))
                                        Black;
                                      rotateLeft rbt successorParent))))))
                    done)
         | _ -> ());
        (match Js.Internal.fn_run1 isLeaf successor with
         | true ->
             ((match (rootGet rbt) == (Some successor) with
               | true -> rootSet rbt None
               | _ -> ());
              (match parentGet successor with
               | None -> ()
               | Some parent -> leftOrRightSet parent ~node:successor None))
         | _ -> ()))
      [@ns.braces ])
    let remove rbt value =
      match _findNode rbt (rootGet rbt) value with
      | Some node ->
          (removeNode rbt node;
           sizeSet rbt ((sizeGet rbt) - 1);
           Some (heightGet node))
      | None -> None
    let findThroughCallback rbt cb =
      ((let rec findThroughCallback rbt node cb =
          match node with
          | None -> None
          | Some node ->
              let cmp = Js.Internal.fn_run1 cb (valueGet node) in
              (match cmp == 0 with
               | true -> Some node
               | _ when cmp < 0 -> findThroughCallback rbt (leftGet node) cb
               | _ -> findThroughCallback rbt (rightGet node) cb) in
        match findThroughCallback rbt (rootGet rbt) cb with
        | None -> None
        | Some node -> Some (valueGet node))
      [@ns.braces ])
    let make ~compare  = t ~size:0 ~root:None ~compare
    let rec heightOfInterval rbt node lhs rhs =
      match node with
      | None -> 0.
      | Some n ->
          (match (lhs == None) && (rhs == None) with
           | true -> sumGet n
           | _ when
               (lhs != None) &&
                 ((Js.Internal.fn_run2 (compareGet rbt) (valueGet n)
                     (castNotOption lhs))
                    < 0)
               -> heightOfInterval rbt (rightGet n) lhs rhs
           | _ when
               (rhs != None) &&
                 ((Js.Internal.fn_run2 (compareGet rbt) (valueGet n)
                     (castNotOption rhs))
                    > 0)
               -> heightOfInterval rbt (leftGet n) lhs rhs
           | _ ->
               ((heightGet n) +. (heightOfInterval rbt (leftGet n) lhs None))
                 +. (heightOfInterval rbt (rightGet n) None rhs))
    let heightOfInterval rbt lhs rhs =
      heightOfInterval rbt (rootGet rbt) lhs rhs
    let rec firstVisibleNode node offset =
      match node with
      | None -> None
      | Some node ->
          (match (sumGet node) <= offset with
           | true -> None
           | _ ->
               let nodeHeight = heightGet node in
               let sumLeft =
                 match leftGet node with
                 | None -> 0.0
                 | Some left -> sumGet left in
               (match sumLeft > offset with
                | true -> firstVisibleNode (leftGet node) offset
                | _ when (sumLeft +. nodeHeight) > offset -> Some node
                | _ ->
                    firstVisibleNode (rightGet node)
                      (offset -. (sumLeft +. nodeHeight))))
    let lastVisibleNode node offset =
      match firstVisibleNode node offset with
      | None -> maxNode node
      | first -> first
    let firstVisible rbt ~offset  =
      match firstVisibleNode (rootGet rbt) offset with
      | None -> None
      | Some node -> Some (valueGet node)
    let rec leftmost node =
      match leftGet node with | None -> node | Some node -> leftmost node
    let rec firstRightParent node =
      match parentGet node with
      | None -> None
      | Some parent ->
          (match isLeft node with
           | true -> Some parent
           | _ -> firstRightParent parent)
    let nextNode node =
      match rightGet node with
      | None -> firstRightParent node
      | Some right -> Some (leftmost right)
    let rec sumLeftSpine node ~fromRightChild  =
      ((let leftSpine =
          match leftGet node with
          | None -> heightGet node
          | Some left ->
              (match fromRightChild with
               | true -> (heightGet node) +. (sumGet left)
               | _ -> 0.0) in
        match parentGet node with
        | None -> leftSpine
        | Some parent ->
            leftSpine +.
              (sumLeftSpine parent
                 ~fromRightChild:((rightGet parent) == (Some node))))
      [@ns.braces ])
    let getY node =
      (sumLeftSpine node ~fromRightChild:true) -. (heightGet node)
    let linearSearch rbt callback =
      ((let rec find node callback =
          match Js.Internal.fn_run1 callback (valueGet node) with
          | true -> Some (valueGet node)
          | _ ->
              (match nextNode node with
               | None -> None
               | Some node -> find node callback) in
        match minNode (rootGet rbt) with
        | None -> None
        | Some node -> find node callback)
      [@ns.braces ])
    let rec iterate ~inclusive  firstNode lastNode ~callback  =
      match firstNode with
      | None -> ()
      | Some node ->
          ((match inclusive with
            | true -> Js.Internal.fn_run1 callback node
            | _ -> ());
           (match firstNode != lastNode with
            | true ->
                ((match not inclusive with
                  | true -> Js.Internal.fn_run1 callback node
                  | _ -> ());
                 iterate ~inclusive (nextNode node) lastNode ~callback)
            | _ -> ()))
    let rec iterateWithY ?y  ~inclusive  firstNode lastNode ~callback  =
      match firstNode with
      | None -> ()
      | Some node ->
          let y = match y with | None -> getY node | Some y -> y in
          ((match inclusive with
            | true -> Js.Internal.fn_run2 callback node y
            | _ -> ());
           (match firstNode != lastNode with
            | true ->
                ((match not inclusive with
                  | true -> Js.Internal.fn_run2 callback node y
                  | _ -> ());
                 iterateWithY ~y:(y +. (heightGet node)) ~inclusive
                   (nextNode node) lastNode ~callback)
            | _ -> ()))
    let rec updateSum node ~delta  =
      match node with
      | None -> ()
      | Some node ->
          (sumSet node ((sumGet node) +. delta);
           updateSum (parentGet node) ~delta)
    let setHeight rbt value ~height  =
      match _findNode rbt (rootGet rbt) value with
      | None -> ()
      | Some node ->
          let delta = height -. (heightGet node) in
          (heightSet node height; updateSum (Some node) ~delta)
    type nonrec 'value oldNewVisibleNodes =
      {
      mutable old: 'value array ;
      mutable new_: 'value array }
  end
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 4, characters 28-36:


2 â”‚            include (
3 â”‚                      {
[31m4[0m â”‚                        type t[31m('value)[0m = {
5 â”‚                          mutable size: int,
6 â”‚                          mutable root: option(node('value)),

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 6, characters 49-57:


4 â”‚                        type t('value) = {
5 â”‚                          mutable size: int,
[31m6[0m â”‚                          mutable root: option(node[31m('value)[0m),
7 â”‚                          compare:
8 â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),

Type parameters require angle brackets:
  node<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 6, characters 44-58:


4 â”‚                        type t('value) = {
5 â”‚                          mutable size: int,
[31m6[0m â”‚                          mutable root: option[31m(node('value))[0m,
7 â”‚                          compare:
8 â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),

Type parameters require angle brackets:
  option<node<'value>>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 41-42:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),          
                                               [31m^[0m
9 â”‚                        };
10 â”‚                      }: {

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 41-42:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),          
                                               [31m^[0m
9 â”‚                        };
10 â”‚                      }: {

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 43-44:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ [31m|[0m \`Arity_2('value, 'value)], int),
9 â”‚                        };
10 â”‚                      }: {

I'm not sure what to parse here when looking at \\"|\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 52-53:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2([31m'[0mvalue, 'value)], int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 60-61:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, [31m'[0mvalue)], int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 68-69:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)][31m,[0m int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 73-74:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int[31m)[0m
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 20, characters 12-13:


18 â”‚                ~root: option(node('value)),
19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
[31m20[0m â”‚              [31m)[0m =>
21 â”‚              t('value) =
22 â”‚              \\"\\"

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 20, characters 14-16:


18 â”‚                ~root: option(node('value)),
19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
[31m20[0m â”‚              ) [31m=>[0m
21 â”‚              t('value) =
22 â”‚              \\"\\"

I'm not sure what to parse here when looking at \\"=>\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 21, characters 14-15:


19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
20 â”‚              ) =>
[31m21[0m â”‚              t([31m'[0mvalue) =
22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 21, characters 22-23:


19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
20 â”‚              ) =>
[31m21[0m â”‚              t('value) [31m=[0m
22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";

Did you mean \`==\` here?


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 24, characters 30-38:


22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";
[31m24[0m â”‚            external sizeSet: (t[31m('value)[0m, int) => unit =
25 â”‚              \\"size\\"
26 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$size@\\";

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 31, characters 26-34:


29 â”‚            ]
30 â”‚            [@internal.arity 1]
[31m31[0m â”‚            external size: t[31m('value)[0m => int =
32 â”‚              \\"\\"
33 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 35, characters 29-37:


33 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
34 â”‚            [@internal.arity 1]
[31m35[0m â”‚            external sizeGet: t[31m('value)[0m => int =
36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 30-38:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t[31m('value)[0m, option(node('value))) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 51-59:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t('value), option(node[31m('value)[0m)) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters require angle brackets:
  node<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 46-60:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t('value), option[31m(node('value))[0m) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters require angle brackets:
  option<node<'value>>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 26-34:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t[31m('value)[0m => option(node('value)) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 49-57:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t('value) => option(node[31m('value)[0m) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters require angle brackets:
  node<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 44-58:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t('value) => option[31m(node('value))[0m =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters require angle brackets:
  option<node<'value>>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 29-37:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t[31m('value)[0m => option(node('value)) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 52-60:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t('value) => option(node[31m('value)[0m) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters require angle brackets:
  node<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 47-61:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t('value) => option[31m(node('value))[0m =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters require angle brackets:
  option<node<'value>>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 13-21:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t[31m('value)[0m => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Type parameters require angle brackets:
  t<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =          
                                              [31m^[0m
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =          
                                              [31m^[0m
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Did you forget a \`=\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([31m[[0m | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

An external definition should have at least one primitive. Example: \\"setTimeout\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 42-43:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ [31m|[0m \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"|\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 53-54:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2([31m'[0mvalue, 'value)], int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 61-62:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, [31m'[0mvalue)], int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 69-70:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)][31m,[0m int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 74-75:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int[31m)[0m =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 76-77:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) [31m=[0m
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"=\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 65, characters 9-10:


63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";
[31m65[0m â”‚          };          
               [31m^[0m
66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
67 â”‚  let rec minNode = node =>

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 67, characters 25-29:


65 â”‚          };
66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
[31m67[0m â”‚  let rec minNode = node =>
68 â”‚  let findMin = rbt =>
69 â”‚  let removeNode = (rbt, node) => {

I'm not sure what to parse here when looking at \\"let\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 68, characters 20-24:


66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
67 â”‚  let rec minNode = node =>
[31m68[0m â”‚  let findMin = rbt =>
69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =

I'm not sure what to parse here when looking at \\"let\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 434, characters 30-38:


432 â”‚      updateSum(Some(node), ~delta);
433 â”‚    };
[31m434[0m â”‚  type nonrec oldNewVisibleNodes[31m('value)[0m = {
435 â”‚    mutable old: array('value),
436 â”‚    mutable new_: array('value),

Type parameters require angle brackets:
  oldNewVisibleNodes<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 435, characters 20-28:


433 â”‚    };
434 â”‚  type nonrec oldNewVisibleNodes('value) = {
[31m435[0m â”‚    mutable old: array[31m('value)[0m,
436 â”‚    mutable new_: array('value),
437 â”‚  };

Type parameters require angle brackets:
  array<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 436, characters 21-29:


434 â”‚  type nonrec oldNewVisibleNodes('value) = {
435 â”‚    mutable old: array('value),
[31m436[0m â”‚    mutable new_: array[31m('value)[0m,
437 â”‚  };

Type parameters require angle brackets:
  array<'value>




File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 437, characters 2-3:


435 â”‚    mutable old: array('value),
436 â”‚    mutable new_: array('value),
[31m437[0m â”‚  };          
        [31m^[0m

Did you forget a \`}\` here? 



========================================================"
`;
