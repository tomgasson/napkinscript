// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`equalAfterBinaryExpr.js 1`] = `
"=====Parsetree==========================================
let rec _addLoop rbt currentNode =
  if (Some currentNode) == (rbt |. root)
  then currentNode.color <- Black
  else
    if (currentNode.parent |. castNotOption).color == Black
    then ()
    else
      if
        (let uncle = uncleOf currentNode in
         (uncle != None) && ((uncle |. castNotOption).color == Red))
      then
        (let () = (currentNode.parent |. castNotOption).color <- Black in
         let () = ((uncleOf currentNode) |. castNotOption).color <- Black in
         let () = ((grandParentOf currentNode) |. castNotOption).color <- Red in
         _addLoop rbt ((grandParentOf currentNode) |. castNotOption))
      else
        (let currentNode =
           if
             (not (isLeft currentNode)) &&
               (isLeft (currentNode.parent |. castNotOption))
           then
             let () = rotateLeft rbt (currentNode.parent |. castNotOption) in
             currentNode.left |. castNotOption
           else
             if
               (isLeft currentNode) &&
                 (not (isLeft (currentNode.parent |. castNotOption)))
             then
               (let () =
                  rotateRight rbt (currentNode.parent |. castNotOption) in
                currentNode.right |. castNotOption)
             else currentNode in
         let () = (currentNode.parent |. castNotOption).color <- Black in
         let () = ((grandParentOf currentNode) |. castNotOption).color <- Red in
         if isLeft currentNode
         then rotateRight rbt ((grandParentOf currentNode) |. castNotOption)
         else rotateLeft rbt ((grandParentOf currentNode) |. castNotOption))
let removeNode rbt node =
  let () =
    if nodeToRemove.color == Black
    then
      (if successor.color == Red
       then
         let () = successor.color <- Black in
         (if successor.parent == None then rbt |. (rootSet (Some successor)))
       else
         (let break = ref false in
          let successorRef = ref successor in
          while not break.contents do
            let successor = successorRef.contents in
            match successor.parent with
            | None ->
                let () = rbt |. (rootSet (Some successor)) in
                break.contents <- true
            | Some successorParent ->
                let sibling = siblingOf successor in
                let () =
                  if
                    (sibling != None) &&
                      ((sibling |. castNotOption).color == Red)
                  then
                    let () = successorParent.color <- Red in
                    let () = (sibling |. castNotOption).color <- Black in
                    (if isLeft successor
                     then rotateLeft rbt successorParent
                     else rotateRight rbt successorParent) in
                let sibling = siblingOf successor in
                let siblingNN = sibling |. castNotOption in
                if
                  (successorParent.color == Black) &&
                    ((sibling == None) ||
                       (((siblingNN.color == Black) &&
                           ((siblingNN.left == None) ||
                              ((siblingNN.left |. castNotOption).color ==
                                 Black)))
                          &&
                          ((siblingNN.right == None) ||
                             ((siblingNN.right |. castNotOption).color ==
                                Black))))
                then
                  let () = if sibling != None then siblingNN.color <- Red in
                  successorRef.contents <- successorParent
                else
                  if
                    (successorParent.color == Red) &&
                      ((sibling == None) ||
                         (((siblingNN.color == Black) &&
                             ((siblingNN.left == None) ||
                                ((siblingNN.left |. castNotOption).color ==
                                   Black)))
                            &&
                            ((siblingNN.right == None) ||
                               ((siblingNN.right |. castNotOption).color ==
                                  Black))))
                  then
                    (let () = if sibling != None then siblingNN.color <- Red in
                     let () = successorParent.color <- Black in
                     break.contents <- true)
                  else
                    if
                      (sibling != None) &&
                        ((sibling |. castNotOption).color == Black)
                    then
                      (let sibling = sibling |. castNotOption in
                       let () =
                         if
                           (((isLeft successor) &&
                               ((sibling.right == None) ||
                                  ((sibling.right |. castNotOption).color ==
                                     Black)))
                              && (sibling.left != None))
                             &&
                             ((sibling.left |. castNotOption).color == Red)
                         then
                           let () = sibling.color <- Red in
                           let () =
                             (sibling.left |. castNotOption).color <- Black in
                           rotateRight rbt sibling
                         else
                           if
                             (((not (isLeft successor)) &&
                                 ((sibling.left == None) ||
                                    ((sibling.left |. castNotOption).color ==
                                       Black)))
                                && (sibling.right != None))
                               &&
                               ((sibling.right |. castNotOption).color == Red)
                           then
                             (let () = sibling.color <- Red in
                              let () =
                                (sibling.right |. castNotOption).color <-
                                  Black in
                              rotateLeft rbt sibling) in
                       break.contents <- true)
                    else
                      (let sibling = siblingOf successor in
                       let sibling = sibling |. castNotOption in
                       let () = sibling.color <- (successorParent.color) in
                       if isLeft successor
                       then
                         let () =
                           (sibling.right |. castNotOption).color <- Black in
                         rotateRight rbt successorParent
                       else
                         (let () =
                            (sibling.left |. castNotOption).color <- Black in
                          rotateLeft rbt successorParent))
            done)) in
  if ((isLeaf successor)[@bs ])
  then (if (rbt |. root) == (Some successor) then (rbt |. root) = None)
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/equalAfterBinaryExpr.js\\", line 169, characters 16-17:


167 â”‚    if isLeaf(. successor) {
168 â”‚      if rbt->root === Some(successor) {
[31m169[0m â”‚        rbt->root [31m=[0m None
170 â”‚      }
171 â”‚    }

Did you mean \`==\` here?



========================================================"
`;

exports[`jsxChildren.js 1`] = `
"=====Parsetree==========================================
type nonrec action =
  | AddUser 
let () = ((string ~children:[] ())[@JSX ])
let (a : action) = AddUser \\"test\\"
;;etype
let () = s = { x = [((i ~children:[] ())[@JSX ])] }
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 1, characters 21-29:


[31m1[0m â”‚  type action = AddUser[31m<string>[0m
2 â”‚  
3 â”‚  let a: action = AddUser(\\"test\\")

Missing </string>


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-18:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                       [31m^[0m

Did you forget a \`(\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^^[0m

Did you forget a \`</\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-20:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list[31m<i>[0m}

Closing jsx name should be the same as the opening name. Did you mean </i> ?


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 8-9:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s [31m=[0m {x:list<i>}

Did you mean \`==\` here?



========================================================"
`;

exports[`nonRecTypes.js 1`] = `
"=====Parsetree==========================================

=====Errors=============================================
File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 21-21:

Possible infinite loop detected


========================================================"
`;
