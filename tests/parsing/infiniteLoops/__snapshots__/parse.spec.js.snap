// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`equalAfterBinaryExpr.js 1`] = `
"=====Parsetree==========================================
let rec _addLoop rbt currentNode =
  if (Some currentNode) == (rbt |. root)
  then currentNode.color <- Black
  else
    if (currentNode.parent |. castNotOption).color == Black
    then ()
    else
      if
        (let uncle = uncleOf currentNode in
         (uncle != None) && ((uncle |. castNotOption).color == Red))
      then
        (let () = (currentNode.parent |. castNotOption).color <- Black in
         let () = ((uncleOf currentNode) |. castNotOption).color <- Black in
         let () = ((grandParentOf currentNode) |. castNotOption).color <- Red in
         _addLoop rbt ((grandParentOf currentNode) |. castNotOption))
      else
        (let currentNode =
           if
             (not (isLeft currentNode)) &&
               (isLeft (currentNode.parent |. castNotOption))
           then
             let () = rotateLeft rbt (currentNode.parent |. castNotOption) in
             currentNode.left |. castNotOption
           else
             if
               (isLeft currentNode) &&
                 (not (isLeft (currentNode.parent |. castNotOption)))
             then
               (let () =
                  rotateRight rbt (currentNode.parent |. castNotOption) in
                currentNode.right |. castNotOption)
             else currentNode in
         let () = (currentNode.parent |. castNotOption).color <- Black in
         let () = ((grandParentOf currentNode) |. castNotOption).color <- Red in
         if isLeft currentNode
         then rotateRight rbt ((grandParentOf currentNode) |. castNotOption)
         else rotateLeft rbt ((grandParentOf currentNode) |. castNotOption))
let removeNode rbt node =
  let () =
    if nodeToRemove.color == Black
    then
      (if successor.color == Red
       then
         let () = successor.color <- Black in
         (if successor.parent == None then rbt |. (rootSet (Some successor)))
       else
         (let break = ref false in
          let successorRef = ref successor in
          while not break.contents do
            let successor = successorRef.contents in
            match successor.parent with
            | None ->
                let () = rbt |. (rootSet (Some successor)) in
                break.contents <- true
            | Some successorParent ->
                let sibling = siblingOf successor in
                let () =
                  if
                    (sibling != None) &&
                      ((sibling |. castNotOption).color == Red)
                  then
                    let () = successorParent.color <- Red in
                    let () = (sibling |. castNotOption).color <- Black in
                    (if isLeft successor
                     then rotateLeft rbt successorParent
                     else rotateRight rbt successorParent) in
                let sibling = siblingOf successor in
                let siblingNN = sibling |. castNotOption in
                if
                  (successorParent.color == Black) &&
                    ((sibling == None) ||
                       (((siblingNN.color == Black) &&
                           ((siblingNN.left == None) ||
                              ((siblingNN.left |. castNotOption).color ==
                                 Black)))
                          &&
                          ((siblingNN.right == None) ||
                             ((siblingNN.right |. castNotOption).color ==
                                Black))))
                then
                  let () = if sibling != None then siblingNN.color <- Red in
                  successorRef.contents <- successorParent
                else
                  if
                    (successorParent.color == Red) &&
                      ((sibling == None) ||
                         (((siblingNN.color == Black) &&
                             ((siblingNN.left == None) ||
                                ((siblingNN.left |. castNotOption).color ==
                                   Black)))
                            &&
                            ((siblingNN.right == None) ||
                               ((siblingNN.right |. castNotOption).color ==
                                  Black))))
                  then
                    (let () = if sibling != None then siblingNN.color <- Red in
                     let () = successorParent.color <- Black in
                     break.contents <- true)
                  else
                    if
                      (sibling != None) &&
                        ((sibling |. castNotOption).color == Black)
                    then
                      (let sibling = sibling |. castNotOption in
                       let () =
                         if
                           (((isLeft successor) &&
                               ((sibling.right == None) ||
                                  ((sibling.right |. castNotOption).color ==
                                     Black)))
                              && (sibling.left != None))
                             &&
                             ((sibling.left |. castNotOption).color == Red)
                         then
                           let () = sibling.color <- Red in
                           let () =
                             (sibling.left |. castNotOption).color <- Black in
                           rotateRight rbt sibling
                         else
                           if
                             (((not (isLeft successor)) &&
                                 ((sibling.left == None) ||
                                    ((sibling.left |. castNotOption).color ==
                                       Black)))
                                && (sibling.right != None))
                               &&
                               ((sibling.right |. castNotOption).color == Red)
                           then
                             (let () = sibling.color <- Red in
                              let () =
                                (sibling.right |. castNotOption).color <-
                                  Black in
                              rotateLeft rbt sibling) in
                       break.contents <- true)
                    else
                      (let sibling = siblingOf successor in
                       let sibling = sibling |. castNotOption in
                       let () = sibling.color <- (successorParent.color) in
                       if isLeft successor
                       then
                         let () =
                           (sibling.right |. castNotOption).color <- Black in
                         rotateRight rbt successorParent
                       else
                         (let () =
                            (sibling.left |. castNotOption).color <- Black in
                          rotateLeft rbt successorParent))
            done)) in
  if ((isLeaf successor)[@bs ])
  then (if (rbt |. root) == (Some successor) then (rbt |. root) = None)
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/equalAfterBinaryExpr.js\\", line 169, characters 16-17:


167 â”‚    if isLeaf(. successor) {
168 â”‚      if rbt->root === Some(successor) {
[31m169[0m â”‚        rbt->root [31m=[0m None
170 â”‚      }
171 â”‚    }

Did you mean \`==\` here?



========================================================"
`;

exports[`jsxChildren.js 1`] = `
"=====Parsetree==========================================
type nonrec action =
  | AddUser 
let () = ((string ~children:[] ())[@JSX ])
let (a : action) = AddUser \\"test\\"
;;etype
let () = s = { x = [((i ~children:[] ())[@JSX ])] }
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 1, characters 21-29:


[31m1[0m â”‚  type action = AddUser[31m<string>[0m
2 â”‚  
3 â”‚  let a: action = AddUser(\\"test\\")

Missing </string>


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-18:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                       [31m^[0m

Did you forget a \`(\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^^[0m

Did you forget a \`</\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-20:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list[31m<i>[0m}

Closing jsx name should be the same as the opening name. Did you mean </i> ?


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 8-9:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s [31m=[0m {x:list<i>}

Did you mean \`==\` here?



========================================================"
`;

exports[`nonRecTypes.js 1`] = `
"=====Parsetree==========================================
include
  struct
    include
      struct
        type nonrec 'value t =
          {
          mutable size: int ;
          mutable root: 'value node option ;
          compare: Js.Internal.fn }
        ;;[|{j|Arity_2('value, 'value)], int),
                      };
                    }: {

                    }
                  );
          type t('value);
          external t:
            (
              ~size: int,
              ~root: option(node('value)),
              ~compare: Js.Internal.fn([ | |j};(
            Arity_2 (value, value))|]
        ;;int
        let () = (t value) = \\"\\"
        ;;\\"BS:6.0.1132149166190000000000#000000000\\\\r000000000&000000000#145160160A160$size@160160A160$root@160160A160'compare@@\\"
        external sizeSet :
          'value t -> int -> unit = \\"size\\"
            \\"BS:6.0.1132149166190000000000021000000000\\\\t000000000026000000000025176160160A145@160160A004003@E151160$size@\\"
        ;;[|((\\"use sizeGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external size :
          'value t -> int = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$size@\\"
        ;;[|((1)[@internal.arity ])|]
        external sizeGet :
          'value t -> int = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$size@\\"
        external rootSet :
          'value t -> 'value node option -> unit = \\"root\\"
            \\"BS:6.0.1132149166190000000000021000000000\\\\t000000000026000000000025176160160A145@160160A004003@E151160$root@\\"
        ;;[|((\\"use rootGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external root :
          'value t -> 'value node option = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$root@\\"
        ;;[|((1)[@internal.arity ])|]
        external rootGet :
          'value t -> 'value node option = \\"\\"
            \\"BS:6.0.1132149166190000000000016000000000007000000000020000000000019176160160A145@@A152160$root@\\"
        ;;[|((\\"use compareGet instead or use {abstract = light} explicitly\\")
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external compare : 'value t -> Js.Internal.fn
        ;;[|{j|Arity_2('value, 'value)], int) =
            \\"\\"
            \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";
          [@internal.arity 1]
          external compareGet:
            t('value) => Js.Internal.fn([ | |j};(
            Arity_2 (value, value))|]
        ;;int
        ;;\\"\\"
        ;;\\"BS:6.0.1132149166190000000000019000000000007000000000020000000000019176160160A145@@A152160'compare@\\"
      end
    let has rbt value = (_findNode rbt (rootGet rbt) value) != None
    let rec minNode node = [%napkinscript.exprhole ]
    let findMin rbt = [%napkinscript.exprhole ]
    let removeNode rbt node =
      let nodeToRemove = match leftGet node with in rightGet node
    ;;Some ()
    ;;Some ()
    let successor = castNotOption (minNode (rightGet node))
    let () = valueSet node (valueGet successor)
    let () = heightSet node (heightGet successor)
    ;;successor
    ;;node
  end
let successor =
  match leftGet nodeToRemove with
  | None -> rightGet nodeToRemove
  | left -> left
let successor = isLeaf
;;match successor with
  | None ->
      let leaf =
        createNode ~value:(Js.Internal.raw_expr \\"0\\") ~color:Black ~height:0. in
      let isLeaf = Js.Internal.fn_mk1 (fun x -> x == leaf) in leaf
;;isLeaf
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 4, characters 28-29:


2 â”‚            include (
3 â”‚                      {
[31m4[0m â”‚                        type t[31m([0m'value) = {
5 â”‚                          mutable size: int,
6 â”‚                          mutable root: option(node('value)),

Type params require diamonds, example: type node<'a>


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 6, characters 44-45:


4 â”‚                        type t('value) = {
5 â”‚                          mutable size: int,
[31m6[0m â”‚                          mutable root: option[31m([0mnode('value)),
7 â”‚                          compare:
8 â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 6, characters 49-50:


4 â”‚                        type t('value) = {
5 â”‚                          mutable size: int,
[31m6[0m â”‚                          mutable root: option(node[31m([0m'value)),
7 â”‚                          compare:
8 â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 40-41:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn[31m([0m[ | \`Arity_2('value, 'value)], int),
9 â”‚                        };
10 â”‚                      }: {

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 41-42:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),          
                                               [31m^[0m
9 â”‚                        };
10 â”‚                      }: {

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 41-42:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ | \`Arity_2('value, 'value)], int),          
                                               [31m^[0m
9 â”‚                        };
10 â”‚                      }: {

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 8, characters 43-44:


6 â”‚                          mutable root: option(node('value)),
7 â”‚                          compare:
[31m8[0m â”‚                            Js.Internal.fn([ [31m|[0m \`Arity_2('value, 'value)], int),
9 â”‚                        };
10 â”‚                      }: {

I'm not sure what to parse here when looking at \\"|\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 52-53:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2([31m'[0mvalue, 'value)], int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 60-61:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, [31m'[0mvalue)], int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 68-69:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)][31m,[0m int)
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 19, characters 73-74:


17 â”‚                ~size: int,
18 â”‚                ~root: option(node('value)),
[31m19[0m â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int[31m)[0m
20 â”‚              ) =>
21 â”‚              t('value) =

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 20, characters 12-13:


18 â”‚                ~root: option(node('value)),
19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
[31m20[0m â”‚              [31m)[0m =>
21 â”‚              t('value) =
22 â”‚              \\"\\"

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 20, characters 14-16:


18 â”‚                ~root: option(node('value)),
19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
[31m20[0m â”‚              ) [31m=>[0m
21 â”‚              t('value) =
22 â”‚              \\"\\"

I'm not sure what to parse here when looking at \\"=>\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 21, characters 14-15:


19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
20 â”‚              ) =>
[31m21[0m â”‚              t([31m'[0mvalue) =
22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 21, characters 22-23:


19 â”‚                ~compare: Js.Internal.fn([ | \`Arity_2('value, 'value)], int)
20 â”‚              ) =>
[31m21[0m â”‚              t('value) [31m=[0m
22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";

Did you mean \`==\` here?


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 24, characters 30-31:


22 â”‚              \\"\\"
23 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000#\\\\000\\\\000\\\\000\\\\r\\\\000\\\\000\\\\000&\\\\000\\\\000\\\\000#\\\\145\\\\160\\\\160A\\\\160$size@\\\\160\\\\160A\\\\160$root@\\\\160\\\\160A\\\\160'compare@@\\";
[31m24[0m â”‚            external sizeSet: (t[31m([0m'value), int) => unit =
25 â”‚              \\"size\\"
26 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$size@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 31, characters 26-27:


29 â”‚            ]
30 â”‚            [@internal.arity 1]
[31m31[0m â”‚            external size: t[31m([0m'value) => int =
32 â”‚              \\"\\"
33 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 35, characters 29-30:


33 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
34 â”‚            [@internal.arity 1]
[31m35[0m â”‚            external sizeGet: t[31m([0m'value) => int =
36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 30-31:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t[31m([0m'value), option(node('value))) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 46-47:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t('value), option[31m([0mnode('value))) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 38, characters 51-52:


36 â”‚              \\"\\"
37 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$size@\\";
[31m38[0m â”‚            external rootSet: (t('value), option(node[31m([0m'value))) => unit =
39 â”‚              \\"root\\"
40 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\021\\\\000\\\\000\\\\000\\\\t\\\\000\\\\000\\\\000\\\\026\\\\000\\\\000\\\\000\\\\025\\\\176\\\\160\\\\160A\\\\145@\\\\160\\\\160A\\\\004\\\\003@E\\\\151\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 26-27:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t[31m([0m'value) => option(node('value)) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 44-45:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t('value) => option[31m([0mnode('value)) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 45, characters 49-50:


43 â”‚            ]
44 â”‚            [@internal.arity 1]
[31m45[0m â”‚            external root: t('value) => option(node[31m([0m'value)) =
46 â”‚              \\"\\"
47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 29-30:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t[31m([0m'value) => option(node('value)) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 47-48:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t('value) => option[31m([0mnode('value)) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 49, characters 52-53:


47 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";
48 â”‚            [@internal.arity 1]
[31m49[0m â”‚            external rootGet: t('value) => option(node[31m([0m'value)) =
50 â”‚              \\"\\"
51 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\016\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160$root@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 13-14:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t[31m([0m'value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 39-40:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn[31m([0m[ | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Type parameters need to be wrapped in angle brackets, not parentheses, like so: \\"Belt.Map.String.t<int>\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =          
                                              [31m^[0m
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) =          
                                              [31m^[0m
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

Did you forget a \`=\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 40-41:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([31m[[0m | \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

An external definition should have at least one primitive. Example: \\"setTimeout\\"


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 57, characters 42-43:


55 â”‚            [@internal.arity 1]
56 â”‚            external compare:
[31m57[0m â”‚              t('value) => Js.Internal.fn([ [31m|[0m \`Arity_2('value, 'value)], int) =
58 â”‚              \\"\\"
59 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"|\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 53-54:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2([31m'[0mvalue, 'value)], int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 61-62:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, [31m'[0mvalue)], int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"'\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 69-70:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)][31m,[0m int) =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 74-75:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int[31m)[0m =
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 62, characters 76-77:


60 â”‚            [@internal.arity 1]
61 â”‚            external compareGet:
[31m62[0m â”‚              t('value) => Js.Internal.fn([ | \`Arity_2('value, 'value)], int) [31m=[0m
63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";

I'm not sure what to parse here when looking at \\"=\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 65, characters 9-10:


63 â”‚              \\"\\"
64 â”‚              \\"BS:6.0.1\\\\132\\\\149\\\\166\\\\190\\\\000\\\\000\\\\000\\\\019\\\\000\\\\000\\\\000\\\\007\\\\000\\\\000\\\\000\\\\020\\\\000\\\\000\\\\000\\\\019\\\\176\\\\160\\\\160A\\\\145@@A\\\\152\\\\160'compare@\\";
[31m65[0m â”‚          };          
               [31m^[0m
66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
67 â”‚  let rec minNode = node =>

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 67, characters 25-29:


65 â”‚          };
66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
[31m67[0m â”‚  let rec minNode = node =>
68 â”‚  let findMin = rbt =>
69 â”‚  let removeNode = (rbt, node) => {

I'm not sure what to parse here when looking at \\"let\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 68, characters 20-24:


66 â”‚  let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
67 â”‚  let rec minNode = node =>
[31m68[0m â”‚  let findMin = rbt =>
69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =

I'm not sure what to parse here when looking at \\"let\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 71, characters 25-26:


69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =
[31m71[0m â”‚      switch (leftGet(node), rightGet(node)) {          
                               [31m^[0m
72 â”‚      | (Some(_), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 71, characters 25-26:


69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =
[31m71[0m â”‚      switch (leftGet(node), rightGet(node)) {          
                               [31m^[0m
72 â”‚      | (Some(_), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));

Did you forget a \`{\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 71, characters 25-26:


69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =
[31m71[0m â”‚      switch (leftGet(node)[31m,[0m rightGet(node)) {
72 â”‚      | (Some(_), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 71, characters 26-35:


69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =
[31m71[0m â”‚      switch (leftGet(node),[31m rightGet[0m(node)) {
72 â”‚      | (Some(_), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));

Pattern matching needs at least one case


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 71, characters 26-35:


69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =
[31m71[0m â”‚      switch (leftGet(node), rightGet(node)) {          
                                [31m^[0m
72 â”‚      | (Some(_), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 71, characters 41-42:


69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =
[31m71[0m â”‚      switch (leftGet(node), rightGet(node)) {          
                                               [31m^[0m
72 â”‚      | (Some(_), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 71, characters 41-42:


69 â”‚  let removeNode = (rbt, node) => {
70 â”‚    let nodeToRemove =
[31m71[0m â”‚      switch (leftGet(node), rightGet(node)[31m)[0m {
72 â”‚      | (Some(_), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 12-13:


70 â”‚    let nodeToRemove =
71 â”‚      switch (leftGet(node), rightGet(node)) {
[31m72[0m â”‚      | (Some([31m_[0m), Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));
74 â”‚        valueSet(node, valueGet(successor));

I'm not sure what to parse here when looking at \\"_\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 14-15:


70 â”‚    let nodeToRemove =
71 â”‚      switch (leftGet(node), rightGet(node)) {
[31m72[0m â”‚      | (Some(_), Some(_)) =>          
                    [31m^[0m
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));
74 â”‚        valueSet(node, valueGet(successor));

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 14-15:


70 â”‚    let nodeToRemove =
71 â”‚      switch (leftGet(node), rightGet(node)) {
[31m72[0m â”‚      | (Some(_), Some(_)) =>          
                    [31m^[0m
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));
74 â”‚        valueSet(node, valueGet(successor));

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 14-15:


70 â”‚    let nodeToRemove =
71 â”‚      switch (leftGet(node), rightGet(node)) {
[31m72[0m â”‚      | (Some(_)[31m,[0m Some(_)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));
74 â”‚        valueSet(node, valueGet(successor));

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 21-22:


70 â”‚    let nodeToRemove =
71 â”‚      switch (leftGet(node), rightGet(node)) {
[31m72[0m â”‚      | (Some(_), Some([31m_[0m)) =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));
74 â”‚        valueSet(node, valueGet(successor));

I'm not sure what to parse here when looking at \\"_\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 23-24:


70 â”‚    let nodeToRemove =
71 â”‚      switch (leftGet(node), rightGet(node)) {
[31m72[0m â”‚      | (Some(_), Some(_)[31m)[0m =>
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));
74 â”‚        valueSet(node, valueGet(successor));

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 25-27:


70 â”‚    let nodeToRemove =
71 â”‚      switch (leftGet(node), rightGet(node)) {
[31m72[0m â”‚      | (Some(_), Some(_)) [31m=>[0m
73 â”‚        let successor = castNotOption(minNode(rightGet(node)));
74 â”‚        valueSet(node, valueGet(successor));

I'm not sure what to parse here when looking at \\"=>\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 77, characters 4-5:


75 â”‚        heightSet(node, heightGet(successor));
76 â”‚        successor;
[31m77[0m â”‚      [31m|[0m _ => node
78 â”‚      };
79 â”‚    let successor =

I'm not sure what to parse here when looking at \\"|\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 77, characters 6-7:


75 â”‚        heightSet(node, heightGet(successor));
76 â”‚        successor;
[31m77[0m â”‚      | [31m_[0m => node
78 â”‚      };
79 â”‚    let successor =

I'm not sure what to parse here when looking at \\"_\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 77, characters 8-10:


75 â”‚        heightSet(node, heightGet(successor));
76 â”‚        successor;
[31m77[0m â”‚      | _ [31m=>[0m node
78 â”‚      };
79 â”‚    let successor =

I'm not sure what to parse here when looking at \\"=>\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 84, characters 16-17:


82 â”‚      | left => left
83 â”‚      };
[31m84[0m â”‚    let (successor, isLeaf) =          
                      [31m^[0m
85 â”‚      switch (successor) {
86 â”‚      | None =>

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 84, characters 16-17:


82 â”‚      | left => left
83 â”‚      };
[31m84[0m â”‚    let (successor, isLeaf) =          
                      [31m^[0m
85 â”‚      switch (successor) {
86 â”‚      | None =>

Did you forget a \`=\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 84, characters 24-25:


82 â”‚      | left => left
83 â”‚      };
[31m84[0m â”‚    let (successor, isLeaf[31m)[0m =
85 â”‚      switch (successor) {
86 â”‚      | None =>

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 84, characters 26-27:


82 â”‚      | left => left
83 â”‚      };
[31m84[0m â”‚    let (successor, isLeaf) [31m=[0m
85 â”‚      switch (successor) {
86 â”‚      | None =>

I'm not sure what to parse here when looking at \\"=\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 94, characters 11-12:


92 â”‚          );
93 â”‚        let isLeaf = Js.Internal.fn_mk1(x => x === leaf);
[31m94[0m â”‚        (leaf, isLeaf);          
                 [31m^[0m
95 â”‚      | Some(successor) => (successor, Js.Internal.fn_mk1(_ => false))
96 â”‚      };

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 94, characters 11-12:


92 â”‚          );
93 â”‚        let isLeaf = Js.Internal.fn_mk1(x => x === leaf);
[31m94[0m â”‚        (leaf[31m,[0m isLeaf);
95 â”‚      | Some(successor) => (successor, Js.Internal.fn_mk1(_ => false))
96 â”‚      };

I'm not sure what to parse here when looking at \\",\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 94, characters 12-19:


92 â”‚          );
93 â”‚        let isLeaf = Js.Internal.fn_mk1(x => x === leaf);
[31m94[0m â”‚        (leaf, isLeaf);          
                  [31m^[0m
95 â”‚      | Some(successor) => (successor, Js.Internal.fn_mk1(_ => false))
96 â”‚      };

Did you forget a \`}\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 94, characters 19-20:


92 â”‚          );
93 â”‚        let isLeaf = Js.Internal.fn_mk1(x => x === leaf);
[31m94[0m â”‚        (leaf, isLeaf[31m)[0m;
95 â”‚      | Some(successor) => (successor, Js.Internal.fn_mk1(_ => false))
96 â”‚      };

I'm not sure what to parse here when looking at \\")\\".


File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 94, characters 20-21:


92 â”‚          );
93 â”‚        let isLeaf = Js.Internal.fn_mk1(x => x === leaf);
[31m94[0m â”‚        (leaf, isLeaf)[31m;[0m
95 â”‚      | Some(successor) => (successor, Js.Internal.fn_mk1(_ => false))
96 â”‚      };

I'm not sure what to parse here when looking at \\";\\".



========================================================"
`;
