// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`equalAfterBinaryExpr.js 1`] = `
"=====Parsetree==========================================
let rec _addLoop rbt currentNode =
  if (Some currentNode) == (rbt |. root)
  then currentNode.color <- Black
  else
    if (currentNode.parent |. castNotOption).color == Black
    then ()
    else
      if
        (let uncle = uncleOf currentNode in
         (uncle != None) && ((uncle |. castNotOption).color == Red))
      then
        ((currentNode.parent |. castNotOption).color <- Black;
         ((uncleOf currentNode) |. castNotOption).color <- Black;
         ((grandParentOf currentNode) |. castNotOption).color <- Red;
         _addLoop rbt ((grandParentOf currentNode) |. castNotOption))
      else
        (let currentNode =
           if
             (not (isLeft currentNode)) &&
               (isLeft (currentNode.parent |. castNotOption))
           then
             (rotateLeft rbt (currentNode.parent |. castNotOption);
              currentNode.left |. castNotOption)
           else
             if
               (isLeft currentNode) &&
                 (not (isLeft (currentNode.parent |. castNotOption)))
             then
               (rotateRight rbt (currentNode.parent |. castNotOption);
                currentNode.right |. castNotOption)
             else currentNode in
         (currentNode.parent |. castNotOption).color <- Black;
         ((grandParentOf currentNode) |. castNotOption).color <- Red;
         if isLeft currentNode
         then rotateRight rbt ((grandParentOf currentNode) |. castNotOption)
         else rotateLeft rbt ((grandParentOf currentNode) |. castNotOption))
let removeNode rbt node =
  if nodeToRemove.color == Black
  then
    (if successor.color == Red
     then
       (successor.color <- Black;
        if successor.parent == None then rbt |. (rootSet (Some successor)))
     else
       (let break = ref false in
        let successorRef = ref successor in
        while not break.contents do
          let successor = successorRef.contents in
          match successor.parent with
          | None ->
              (rbt |. (rootSet (Some successor)); break.contents <- true)
          | Some successorParent ->
              let sibling = siblingOf successor in
              (if
                 (sibling != None) &&
                   ((sibling |. castNotOption).color == Red)
               then
                 (successorParent.color <- Red;
                  (sibling |. castNotOption).color <- Black;
                  if isLeft successor
                  then rotateLeft rbt successorParent
                  else rotateRight rbt successorParent);
               (let sibling = siblingOf successor in
                let siblingNN = sibling |. castNotOption in
                if
                  (successorParent.color == Black) &&
                    ((sibling == None) ||
                       (((siblingNN.color == Black) &&
                           ((siblingNN.left == None) ||
                              ((siblingNN.left |. castNotOption).color ==
                                 Black)))
                          &&
                          ((siblingNN.right == None) ||
                             ((siblingNN.right |. castNotOption).color ==
                                Black))))
                then
                  (if sibling != None then siblingNN.color <- Red;
                   successorRef.contents <- successorParent)
                else
                  if
                    (successorParent.color == Red) &&
                      ((sibling == None) ||
                         (((siblingNN.color == Black) &&
                             ((siblingNN.left == None) ||
                                ((siblingNN.left |. castNotOption).color ==
                                   Black)))
                            &&
                            ((siblingNN.right == None) ||
                               ((siblingNN.right |. castNotOption).color ==
                                  Black))))
                  then
                    (if sibling != None then siblingNN.color <- Red;
                     successorParent.color <- Black;
                     break.contents <- true)
                  else
                    if
                      (sibling != None) &&
                        ((sibling |. castNotOption).color == Black)
                    then
                      (let sibling = sibling |. castNotOption in
                       if
                         (((isLeft successor) &&
                             ((sibling.right == None) ||
                                ((sibling.right |. castNotOption).color ==
                                   Black)))
                            && (sibling.left != None))
                           && ((sibling.left |. castNotOption).color == Red)
                       then
                         (sibling.color <- Red;
                          (sibling.left |. castNotOption).color <- Black;
                          rotateRight rbt sibling)
                       else
                         if
                           (((not (isLeft successor)) &&
                               ((sibling.left == None) ||
                                  ((sibling.left |. castNotOption).color ==
                                     Black)))
                              && (sibling.right != None))
                             &&
                             ((sibling.right |. castNotOption).color == Red)
                         then
                           (sibling.color <- Red;
                            (sibling.right |. castNotOption).color <- Black;
                            rotateLeft rbt sibling);
                       break.contents <- true)
                    else
                      (let sibling = siblingOf successor in
                       let sibling = sibling |. castNotOption in
                       sibling.color <- (successorParent.color);
                       if isLeft successor
                       then
                         ((sibling.right |. castNotOption).color <- Black;
                          rotateRight rbt successorParent)
                       else
                         ((sibling.left |. castNotOption).color <- Black;
                          rotateLeft rbt successorParent))))
          done));
  if ((isLeaf successor)[@bs ])
  then (if (rbt |. root) == (Some successor) then (rbt |. root) = None)
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/equalAfterBinaryExpr.js\\", line 169, characters 16-17:


167 â”‚    if isLeaf(. successor) {
168 â”‚      if rbt->root === Some(successor) {
[31m169[0m â”‚        rbt->root [31m=[0m None
170 â”‚      }
171 â”‚    }

Did you mean \`==\` here?



========================================================"
`;

exports[`jsxChildren.js 1`] = `
"=====Parsetree==========================================
type nonrec action =
  | AddUser 
let () = ((string ~children:[] ())[@JSX ])
let (a : action) = AddUser \\"test\\"
;;etype
let () = s = { x = [((i ~children:[] ())[@JSX ])] }
=====Errors=============================================

File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 1, characters 21-29:


[31m1[0m â”‚  type action = AddUser[31m<string>[0m
2 â”‚  
3 â”‚  let a: action = AddUser(\\"test\\")

Missing </string>


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-18:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                       [31m^[0m

Did you forget a \`(\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^^[0m

Did you forget a \`</\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 17-20:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list[31m<i>[0m}

Closing jsx name should be the same as the opening name. Did you mean </i> ?


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`>\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 20-21:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s = {x:list<i>}          
                          [31m^[0m

Did you forget a \`)\` here? 


File \\"/napkinscript/tests/parsing/infiniteLoops/jsxChildren.js\\", line 5, characters 8-9:


3 â”‚  let a: action = AddUser(\\"test\\")
4 â”‚  
[31m5[0m â”‚  etype s [31m=[0m {x:list<i>}

Did you mean \`==\` here?



========================================================"
`;

exports[`nonRecTypes.js 1`] = `
"=====Parsetree==========================================

=====Errors=============================================
File \\"/napkinscript/tests/parsing/infiniteLoops/nonRecTypes.js\\", line 72, characters 21-21:

Possible infinite loop detected


========================================================"
`;
